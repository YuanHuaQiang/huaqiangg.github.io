<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Huaqianggg|Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="个人记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Huaqianggg|Blog">
<meta property="og:url" content="https://yuanhuaqiang.github.io/index.html">
<meta property="og:site_name" content="Huaqianggg|Blog">
<meta property="og:description" content="个人记录博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="YuanHuaQiang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Huaqianggg|Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Huaqianggg|Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yuanhuaqiang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TCP和UDP协议在应用场景上的差异" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/22/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82/" class="article-date">
  <time class="dt-published" datetime="2024-08-22T06:36:03.000Z" itemprop="datePublished">2024-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/22/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82/">TCP 和 UDP 协议在应用场景上的差异</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TCP应用场景：</p>
<pre><code>•文件传输：如 FTP（File Transfer Protocol）等需要确保数据完整性的应用。
•电子邮件：如 SMTP（Simple Mail Transfer Protocol）等需要可靠传输的应用。
•网页浏览：如 HTTP/HTTPS，这些协议基于 TCP 来确保网页数据的可靠性和完整性。
•远程登录：如 SSH、Telnet 等需要保证数据安全和可靠性的场景。
</code></pre>
<p>UDP 应用场景：</p>
<pre><code>•实时音视频传输：如 VoIP（Voice over IP）、视频会议、在线直播等对延迟敏感的应用，数据丢失的少量容忍度较高。
•在线游戏：实时在线游戏需要快速传输数据，对延迟要求高，UDP 能够满足低延迟的需求，即使数据包丢失也不会显著影响游戏体验。
•广播和组播：如 DHCP（Dynamic Host Configuration Protocol）、DNS（Domain Name System）查询等应用，通常在广播或组播环境下使用 UDP。
•简单的请求-响应服务：如 DNS 查询，由于请求的数据量小且传输速度快，使用 UDP 更为高效。
</code></pre>
<p>总结</p>
<pre><code>•TCP 适用于需要保证数据可靠性、顺序性和完整性的场景，如文件传输、电子邮件、网页浏览和远程登录。
•UDP 适用于对实时性要求高、容忍少量数据丢失、对可靠性要求不高的场景，如实时音视频传输、在线游戏、广播和组播。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2024/08/22/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82/" data-id="cm04x8bv90004e9q4d26s810b" data-title="TCP 和 UDP 协议在应用场景上的差异" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySql-索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/22/MySql-%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2024-08-22T03:40:15.000Z" itemprop="datePublished">2024-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/22/MySql-%E7%B4%A2%E5%BC%95/">MySql-索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 MySQL 的 InnoDB 存储引擎中，直接创建哈希索引是不被支持的。InnoDB 引擎默认使用 B-tree 索引结构，并且不允许手动指定索引类型为哈希索引。</p>
<p>不过，InnoDB 会在某些情况下自动使用哈希索引的特性。具体来说，InnoDB 引擎在处理自适应哈希索引（Adaptive Hash Index, AHI）时，会根据查询模式动态地将一些 B-tree 索引部分转换为哈希索引，以加速等值查询。</p>
<p>自适应哈希索引（Adaptive Hash Index, AHI）是 InnoDB 存储引擎的一个自动优化特性，用于加速特定查询的性能。InnoDB 根据实际的查询模式来决定是否为某些 B-tree 索引生成哈希索引部分，以优化等值查询的速度。这个过程主要与查询模式和访问频率有关，而不是直接根据字段类型来决定。</p>
<p>解释 MySQL 中索引的类型（B-tree、Hash 等）及适用场景。</p>
<ol>
<li>B-tree 索引</li>
</ol>
<p>适用场景：</p>
<p>• 范围查询：B-tree 索引适合于范围查询，例如 BETWEEN、&lt;、&gt; 等操作。这是因为 B-tree 结构中的节点是有序的，可以快速找到范围内的记录。<br>• 排序操作：B-tree 索引在进行排序操作时也很高效，因为数据在索引中的顺序与实际数据顺序一致。<br>• 主键和唯一索引：通常情况下，B-tree 索引用于主键和唯一索引，以确保数据的唯一性和快速查找。<br>2. Hash 索引</p>
<p>适用场景：</p>
<p>• 等值查询：Hash 索引非常适合等值查询（例如 &#x3D; 或者 IN），因为 Hash 索引基于哈希算法，可以直接定位到具体的记录。<br>• 高并发查询：在高并发的情况下，Hash 索引因为其快速查找的特性，可以提升查询性能。<br>总结</p>
<p>•	B-tree 索引适合大多数查询场景，包括等值查询和范围查询，是 MySQL 中最常用的索引类型。<br>•	Hash 索引适合高性能的等值查询，但不支持范围查询和排序操作。<br>•	Full-text 索引适合全文搜索，但不适合精确匹配。<br>•	R-tree 索引适合地理空间数据查询，常用于 GIS 系统中。<br>•	聚簇索引通常用于主键索引，适合需要快速数据检索的场景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2024/08/22/MySql-%E7%B4%A2%E5%BC%95/" data-id="cm04qkug500002lejegbxha1h" data-title="MySql-索引" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021-04-17面试嘉立创" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/2021-04-17%E9%9D%A2%E8%AF%95%E5%98%89%E7%AB%8B%E5%88%9B/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T05:47:01.000Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/18/2021-04-17%E9%9D%A2%E8%AF%95%E5%98%89%E7%AB%8B%E5%88%9B/">2021/04/17面试嘉立创</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Oracle 数据类型：</strong></p>
<ul>
<li>字符串类型 char nchar varchar nvarchar2</li>
<li>数字类型 number integer</li>
<li>日期类型 date TIMESTAMP</li>
<li>LOB类型 BLOB二进制 CLOB大文本</li>
</ul>
<p><strong>Redis 数据类型</strong>：String、 List 、Set、Sorted Set、 Hash</p>
<p><strong>5.0的新类型</strong>：</p>
<ul>
<li>Bit arrays：位集合（可以实现类似布隆过滤器的功能结构）</li>
<li>HyperLogLog：是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。</li>
<li>Geospatial Indexes：地理空间索引</li>
<li>Streams：流信息</li>
</ul>
<p><strong>Redis哨兵模式</strong></p>
<p>sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。</p>
<p><strong>RabbitMQ工作模式</strong></p>
<p>简单队列模式、工作队列模式、发布订阅模式、路由模式、主题模式</p>
<p><strong>创建线程方式</strong></p>
<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>
<p>线程池使用</p>
<p><strong>Map子类</strong></p>
<p>HashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap</p>
<p><strong>JDK1.8Stream方法</strong></p>
<p>filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</p>
<p><strong>MySQL数据类型</strong></p>
<p>数值、日期&#x2F;时间和字符串(字符)类型</p>
<p>int、double、decimal、date、time、char、varchar、text、blob</p>
<p><strong>事务特性</strong></p>
<p>ACID 原子性、一致性、隔离性、持久性</p>
<ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1">1]</a></li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A">级联回滚</a>等。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1">1]</a></li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1">1]</a></li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><strong>Git和SVN区别</strong></p>
<p>SVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。</p>
<p><strong>Meven父子项目包</strong></p>
<p>父工程保留pom.xml并在modles添加子工程 ，在子工程pom中依赖父工程并在build添加maven打包依赖</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/18/2021-04-17%E9%9D%A2%E8%AF%95%E5%98%89%E7%AB%8B%E5%88%9B/" data-id="cle2hptjm0005joeja8m68861" data-title="2021/04/17面试嘉立创" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-04-16面试木光" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/2021-04-16%E9%9D%A2%E8%AF%95%E6%9C%A8%E5%85%89/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T05:46:44.000Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/18/2021-04-16%E9%9D%A2%E8%AF%95%E6%9C%A8%E5%85%89/">2021/04/16面试木光</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>WebSocket使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onopen </span><br><span class="line">onmessage </span><br><span class="line">onclose </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldEndpoint</span> &#123;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received : &quot;</span>+ message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket opened: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnClose</span><span class="params">(CloseReason reason)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing a WebSocket due to &quot;</span> + reason.getReasonPhrase());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux根据进程号查找端口号</strong></p>
<p>netstat -nap |grep pid</p>
<p><strong>原生提供接口</strong></p>
<p>使用javax.ws.rs包下的@Path和@Post@Get</p>
<p>Servlet</p>
<p><strong>war包目录</strong></p>
<p>WEB-INF</p>
<p>​	-classes</p>
<p>​	-lib</p>
<p><strong>如何访问web-inf下的jsp文件</strong></p>
<p>接口中直接return文件名（转发）</p>
<p><strong>重定向和转发区别</strong></p>
<p>转发是服务器行为，重定向是客户端行为。</p>
<p><strong>Session和Cookie</strong></p>
<p><strong>什么是 Cookie</strong></p>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>什么是 Session</strong></p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p><strong>Dubbo提供的RPC协议</strong></p>
<p>dubbo、rmi、hessian、http、webservice、thrift、redis</p>
<p><strong>线程创建方式</strong></p>
<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>
<p><strong>设置线程超时中断（使用Future）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Object&gt; future = exec.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    future.cancel(<span class="literal">true</span>);<span class="comment">//必须代码</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/18/2021-04-16%E9%9D%A2%E8%AF%95%E6%9C%A8%E5%85%89/" data-id="cle2hptjl0003joej2tb62sgw" data-title="2021/04/16面试木光" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis分布式锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T11:43:52.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>(1) 锁的可靠性具备的四个方面</p>
<p>互斥性：在任意时刻，只有一个客户端能持有锁。<br>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br>具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。<br>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。<br>(2) 加锁</p>
<p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p>
<p>第一个为key，我们使用key来当锁，因为key是唯一的。<br>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。<br>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；<br>第四个为expx，这个参数我们传的是EX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。<br>第五个为time，与第四个参数相呼应，代表key的过期时间。<br>总的来说，执行上面的set()方法就只会导致两种结果：</p>
<p>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。<br>已有锁存在，不做任何操作。<br>我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/15/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="cle2hptjn0006joejddib1vcy" data-title="Redis分布式锁" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021-04-14面试云集智造" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/2021-04-14%E9%9D%A2%E8%AF%95%E4%BA%91%E9%9B%86%E6%99%BA%E9%80%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T08:17:38.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/2021-04-14%E9%9D%A2%E8%AF%95%E4%BA%91%E9%9B%86%E6%99%BA%E9%80%A0/">2021/04/14面试云集智造</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="个人技术评估"><a href="#个人技术评估" class="headerlink" title="个人技术评估"></a>个人技术评估</h4><ul>
<li>对源码的了解</li>
</ul>
<h4 id="基础与框架"><a href="#基础与框架" class="headerlink" title="基础与框架"></a>基础与框架</h4><ul>
<li><p>Integer：缓存了从-128到127之间的所有的整数对象，自动装箱调用方法Integer的intValue方法</p>
</li>
<li><p>自定义配置项 @Value ，@Configration</p>
</li>
<li><p>Redis数据类型 String、List、Hash、Set、SortedSet</p>
</li>
<li><p>Redis设置过期时间：set后expire 或set(key, value, “NX”, “EX”, expireSecond); 命令 <code>set key value ex 100 nx </code> redistemplate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(codeKey, code, 20, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring 模式单例 @Scope(“prototype”)</p>
</li>
<li><p>@Controller单线程还是多线程： 单例多线程</p>
</li>
<li><p>mysql连接字符串concat(str1,str2)</p>
</li>
<li><p>主表字段更新到子表 update b letf join a on a.id &#x3D; b.pid set col1 &#x3D; a.col1</p>
</li>
<li><p>设计分布式编码生成规则</p>
</li>
<li><p>RabbitMQ消息幂等 全局ID判断是否存在 ，后需考虑何时删除</p>
</li>
</ul>
<h4 id="加强分布式和微服务"><a href="#加强分布式和微服务" class="headerlink" title="加强分布式和微服务"></a>加强分布式和微服务</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/15/2021-04-14%E9%9D%A2%E8%AF%95%E4%BA%91%E9%9B%86%E6%99%BA%E9%80%A0/" data-id="cle2hptjm0004joejhlut0od4" data-title="2021/04/14面试云集智造" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring代理那些事" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/13/Spring%E4%BB%A3%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-13T15:25:56.000Z" itemprop="datePublished">2021-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/13/Spring%E4%BB%A3%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B/">Spring代理那些事</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>SpringBoot2.0之前对接口默认试用JDK动态代理<br>JDK动态代理会生成一个继承自Proxy类的子类并实现原有接口</p>
<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p>CGLIB代理通过生成一个代理对象的子类来实现代理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/13/Spring%E4%BB%A3%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B/" data-id="cle2hptjp0009joej820t6tin" data-title="Spring代理那些事" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/11/Spring%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2021-04-11T16:45:59.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/11/Spring%E4%BA%8B%E5%8A%A1/">Spring事务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="ACID属性"><a href="#ACID属性" class="headerlink" title="ACID属性"></a><strong>ACID属性</strong></h4><p>提到事务，不可避免需要涉及到事务的ACID属性：</p>
<ul>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
</li>
<li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p>
</li>
<li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
</li>
<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p><strong>不可重复度和幻读区别：</strong></p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<h5 id="TransactionDefinition-接口中定义了五个表示隔离级别的常量："><a href="#TransactionDefinition-接口中定义了五个表示隔离级别的常量：" class="headerlink" title="TransactionDefinition 接口中定义了五个表示隔离级别的常量："></a>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</h5><ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>	使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 	允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 	最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>子事务回滚，父事务一定回滚,父事务回滚，子事务一定回滚</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210114091759506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210114091904968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h4 id="为什么会有传播机制"><a href="#为什么会有传播机制" class="headerlink" title="为什么会有传播机制"></a>为什么会有传播机制</h4><p>spring 对事务的控制，是使用 aop 切面实现的，我们不用关心事务的开始，提交 ，回滚，只需要在public方法上加 <code>@Transactional</code> 注解，这时候就有问题了。</p>
<ul>
<li>场景一： serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚。</li>
<li>场景二：serviceA 方法调用了 serviceB 方法，但是只有 serviceA 方法加了事务，是否把 serviceB 也加入 serviceA 的事务，如果 serviceB 异常，是否回滚 serviceA 。</li>
<li>场景三：serviceA 方法调用了 serviceB 方法，两者都有事务，serviceB 已经正常执行完，但 serviceA 异常，是否需要回滚 serviceB 的数据。 回滚</li>
</ul>
<h3 id="传播机制生效条件"><a href="#传播机制生效条件" class="headerlink" title="传播机制生效条件"></a>传播机制生效条件</h3><p>spring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的</p>
<h4 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h4><ol>
<li>@Transactional 应用在非 public 修饰的方法上</li>
<li>@Transactional 注解属性 propagation 设置错误</li>
<li>@Transactional 注解属性 rollbackFor 设置错误</li>
<li>同一个类中方法调用，导致@Transactional失效</li>
<li>异常被你的 catch“吃了”导致@Transactional失效</li>
<li>数据库引擎不支持事务</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/11/Spring%E4%BA%8B%E5%8A%A1/" data-id="cle2hptjo0008joejfhisgvln" data-title="Spring事务" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-模拟面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/11/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-11T14:30:58.000Z" itemprop="datePublished">2021-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/11/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/">模拟面试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>resize（） tanster（） 数组+链表&#x2F;红黑树 并发使用CurrentHashMap 分段锁 HashTable整锁</li>
<li>为什么是2倍？ 方便位运算 rehash</li>
</ul>
<h4 id="CurrentHashMap"><a href="#CurrentHashMap" class="headerlink" title="CurrentHashMap"></a>CurrentHashMap</h4><ul>
<li>结构与HashMap基本一致，Node包括 key value next 指向下一Node</li>
<li>负载因子不可修改</li>
<li>Node.hash字段一般&gt;&#x3D;0  :</li>
<li>线程安全 sychronized 锁通的头节点  若为空则CAS</li>
<li>寻址算法：key的hashcode 扰动运算  高16低16</li>
</ul>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li><p>事务隔离级别、传播特性</p>
</li>
<li><p>AOP 动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p>
</li>
</ul>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul>
<li>观察者模式：一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象；rabbitmq中的fanout模式</li>
<li>代理模式：给一个对象提供一个对象，通过代理对象控制源对象的引用。生活中例子 中介；</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>主键、唯一、联合、全文、普通，聚簇索引 叶子节点 行数据  回表查询</li>
</ul>
<h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><ul>
<li><p>Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。注解为**@LoadBalanced**  与Nginx区别：Nginx服务端，Ribbon客户端</p>
</li>
<li><p>Hystrix预防雪崩：友好提示，</p>
<ul>
<li><p>服务降级：接口调用失败就调用本地的方法返回一个空</p>
</li>
<li><p>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</p>
</li>
<li><p>服务隔离：隔离服务之间相互影响</p>
</li>
<li><p>服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</p>
</li>
</ul>
</li>
<li><p>服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</p>
</li>
<li><p>服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。</p>
</li>
<li><p>服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。</p>
</li>
<li><p>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 <strong>调用方法要和本地抽象方法的签名完全一致</strong></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/11/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" data-id="cle2hptjs000ejoeja8qz9d3w" data-title="模拟面试" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringCloud开启DashBoard监控" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/11/SpringCloud%E5%BC%80%E5%90%AFDashBoard%E7%9B%91%E6%8E%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-11T07:49:02.000Z" itemprop="datePublished">2021-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/11/SpringCloud%E5%BC%80%E5%90%AFDashBoard%E7%9B%91%E6%8E%A7/">SpringCloud开启DashBoard监控</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>导入DashBoard依赖</li>
<li>在需要监控的服务中导入actuator依赖，注入一个Bean将 <code>registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);</code></li>
<li>在需要监控的接口加上@HystrixCommand注解</li>
<li>启动类添加@EnableCircuitBreaker注解</li>
<li>监控服务参数修改 hystrix.dashboard.proxy-stream-allow-list: “*”</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/11/SpringCloud%E5%BC%80%E5%90%AFDashBoard%E7%9B%91%E6%8E%A7/" data-id="cle2hptjo0007joejf2wghram" data-title="SpringCloud开启DashBoard监控" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/interview/" style="font-size: 20px;">interview</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/22/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82/">TCP 和 UDP 协议在应用场景上的差异</a>
          </li>
        
          <li>
            <a href="/2024/08/22/MySql-%E7%B4%A2%E5%BC%95/">MySql-索引</a>
          </li>
        
          <li>
            <a href="/2021/04/18/2021-04-17%E9%9D%A2%E8%AF%95%E5%98%89%E7%AB%8B%E5%88%9B/">2021/04/17面试嘉立创</a>
          </li>
        
          <li>
            <a href="/2021/04/18/2021-04-16%E9%9D%A2%E8%AF%95%E6%9C%A8%E5%85%89/">2021/04/16面试木光</a>
          </li>
        
          <li>
            <a href="/2021/04/15/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 YuanHuaQiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>