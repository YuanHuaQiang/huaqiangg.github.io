<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>2021/04/07面试华曦达 | Huaqianggg|Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java基础：String 不可变 StringBuffer 可变 HashMap HashTable 覆盖key null值key  线程安全 数组+链表&#x2F;红黑树 IO常用类OutputStream、InputStream、FileInputStream、Buffed、FileReader 线程wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。进入wait状态的">
<meta property="og:type" content="article">
<meta property="og:title" content="2021&#x2F;04&#x2F;07面试华曦达">
<meta property="og:url" content="https://yuanhuaqiang.github.io/2021/04/07/2021-04-07%E9%9D%A2%E8%AF%95%E5%8D%8E%E6%9B%A6%E8%BE%BE/index.html">
<meta property="og:site_name" content="Huaqianggg|Blog">
<meta property="og:description" content="Java基础：String 不可变 StringBuffer 可变 HashMap HashTable 覆盖key null值key  线程安全 数组+链表&#x2F;红黑树 IO常用类OutputStream、InputStream、FileInputStream、Buffed、FileReader 线程wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。进入wait状态的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-07T09:12:26.000Z">
<meta property="article:modified_time" content="2023-02-13T07:21:53.611Z">
<meta property="article:author" content="YuanHuaQiang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Huaqianggg|Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Huaqianggg|Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yuanhuaqiang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2021-04-07面试华曦达" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/2021-04-07%E9%9D%A2%E8%AF%95%E5%8D%8E%E6%9B%A6%E8%BE%BE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T09:12:26.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      2021/04/07面试华曦达
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Java基础："><a href="#Java基础：" class="headerlink" title="Java基础："></a>Java基础：</h3><p>String 不可变 StringBuffer 可变</p>
<p>HashMap HashTable 覆盖key null值key  线程安全 数组+链表&#x2F;红黑树</p>
<p>IO常用类<br>OutputStream、InputStream、FileInputStream、Buffed、FileReader</p>
<p>线程<br>wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。<br>进入wait状态的线程能够被notify和notifyAll线程唤醒，并且会释放实例对象所持有的锁。sleep不会被唤醒，也不会释放锁。<br>Java中的wait方法应在同步代码块中调用，sleep则没要求。</p>
<p>synchronized 在方法和类上的区别<br>如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。<br>如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。</p>
<p>线程池使用：ThreadPoolExecutor<br>corePoolSize 为线程池的基本大小。<br>maximumPoolSize 为线程池最大线程大小。<br>keepAliveTime 和 unit 则是线程空闲后的存活时间。<br>workQueue 用于存放任务的阻塞队列。<br>handler 当队列和最大线程池都满了之后的饱和策略。<br>SpringBoot使用<br>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TreadPoolConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 消费队列线程</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(value = &quot;consumerQueueThreadPool&quot;)</span><br><span class="line">    public ExecutorService buildConsumerQueueThreadPool()&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();</span><br><span class="line">        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        return pool ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name = &quot;consumerQueueThreadPool&quot;)</span><br><span class="line">private ExecutorService consumerQueueThreadPool;</span><br><span class="line">@Override</span><br><span class="line">public void execute() &#123;</span><br><span class="line">    //消费队列</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        consumerQueueThreadPool.execute(new ConsumerQueueThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态资源初始化时间 ：静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</p>
<p>Servlet初始化 ：可以配置类加载初始化，默认调用时被初始化</p>
<p>Servlet生命周期：实例化- -&gt;初始化- -&gt;执行处理- -&gt;销毁</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="RabbitMQ："><a href="#RabbitMQ：" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h4><p>Producer： 消息生产者，就是投递消息的程序<br>Consumer： 消息消费者，就是接受消息的程序<br>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>返回json xml produces &#x3D; { “application&#x2F;xml;charset&#x3D;UTF-8” })</p>
<p>国际化</p>
<h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>获取镜像：docker pull <br>查看镜像：docker images<br>查看镜像体积：docker system df <br>删除镜像 ： docker rmi 镜像名称或镜像id<br>虚悬镜像：查看镜像 docker images <br>显示正在运行的容器：docker ps <br>显示所有容器，包括运行和没有运行的 : docker ps -a<br><none> 为无效镜像，虚悬镜像<br>删除虚悬镜像：docker image prune<br>中间层镜像：docker images ls -a  查看所有的镜像<br>     中间层镜像是 镜像本身以来的其他镜像，只不过么有显示依赖镜像的名称，不能删除<br>     例如tomcat:  tomcat 镜像依赖于jar镜像，但是在显示镜像的时候，jar镜像的名称并没有显示jar，而是显示的<none> ，这样的镜像被称为中间层镜像，不能删除中间层镜像；</p>
<p>启动容器：docker run  -p 8080(宿主机端口):8080(容器端口)<br>docker run -p 8080:8080 –name tomcatname -d tomcat<br> dokcer运行 端口做映射， 启动一个名称叫做tomcatname 的容器，以tomcat 镜像<br> 停止容器：docker stop 容器名称或容器ip<br> 删除容器：docker rm 容器名称或容器id<br> 强制删除容器：docker rm -f 容器名称或id<br>启动之前停止的容器：docker start  容器id<br>删除停止的容器：docker rm 容器名称或id<br>删除所有的停止的容器：  docker container prune<br>https: 默认的端口是443，ssl连接 <br>http：默认端口是80<br>交互式进入容器内部：<br>docker exec -it  容器名称或id &#x2F;bin&#x2F;bash<br>&#x2F;bin&#x2F;bash ,使用shell执行命令</p>
<h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>lsot -i:port 、ps -ef|grep xxx、tail -f xxx、more 、cat</p>
<h3 id="SQL查询慢定位问题"><a href="#SQL查询慢定位问题" class="headerlink" title="SQL查询慢定位问题"></a>SQL查询慢定位问题</h3><p>查询执行计划 EXPLAIN慢查询日志里出现的SELECT查询<br>explain列的解释<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index、all<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句<br>key： 实际使用的索引。如果为null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引。这种情况下，可以在select语句中使用use index(indexname)来强制使用一个索引或者用ignore index(indexname)来强制mysql忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：mysql认为必须检查的用来返回请求数据的行数<br>extra：关于mysql如何解析查询的额外信息。例子:using temporary和using filesort，意思mysql根本不能使用索引，结果是检索会很慢</p>
<h3 id="深刻的问题"><a href="#深刻的问题" class="headerlink" title="深刻的问题"></a>深刻的问题</h3><p>static类注入 PostConstruct Spring生命周期</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuanhuaqiang.github.io/2021/04/07/2021-04-07%E9%9D%A2%E8%AF%95%E5%8D%8E%E6%9B%A6%E8%BE%BE/" data-id="cle2hptjk0002joej2k7tb0ke" data-title="2021/04/07面试华曦达" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/07/docker-compose-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          docker-compose 常用命令
        
      </div>
    </a>
  
  
    <a href="/2021/04/06/2021-04-06%E9%9D%A2%E8%AF%95%E5%BA%B7%E7%BE%8E/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">2021/04/06面试康美</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/18/2021-04-17%E9%9D%A2%E8%AF%95%E5%98%89%E7%AB%8B%E5%88%9B/">2021/04/17面试嘉立创</a>
          </li>
        
          <li>
            <a href="/2021/04/18/2021-04-16%E9%9D%A2%E8%AF%95%E6%9C%A8%E5%85%89/">2021/04/16面试木光</a>
          </li>
        
          <li>
            <a href="/2021/04/15/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a>
          </li>
        
          <li>
            <a href="/2021/04/15/2021-04-14%E9%9D%A2%E8%AF%95%E4%BA%91%E9%9B%86%E6%99%BA%E9%80%A0/">2021/04/14面试云集智造</a>
          </li>
        
          <li>
            <a href="/2021/04/13/Spring%E4%BB%A3%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B/">Spring代理那些事</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 YuanHuaQiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>