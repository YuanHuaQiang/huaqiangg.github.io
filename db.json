{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1676259593946},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"b45db38296be2825cb3a6f97c8a0de6197992341","modified":1676259601237},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":499162500000},{"_id":"public/2023/02/13/hello-world/index.html","hash":"7d3348c81da35cc7e64fefe40df73b9778b1c603","modified":1676273089002},{"_id":"public/archives/index.html","hash":"74dfc5a4016ac4b90d8abf53417472c598098f67","modified":1676273089002},{"_id":"public/archives/2023/index.html","hash":"2275e41569539b032b60b21781a3c326aea1c2d9","modified":1676273089002},{"_id":"public/archives/2023/02/index.html","hash":"58eea3477469d5dd61d996e841448f638284b2ca","modified":1676273089002},{"_id":"public/index.html","hash":"c4e92808c62e433c81f15cda9c36145c0f797bc5","modified":1676273089002},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1676259710137},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1676259710137},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1676259710137},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1676259710137},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1676259710137},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1676259710137},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1676259710137},{"_id":"public/css/style.css","hash":"4da345d832a2682bcaee3ab3e22c15e3cd0e9cde","modified":1676259710137},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1676259710137},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1676259710137},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1676259710137},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1676259710137},{"_id":"source/_posts/MySQL创建用户并赋予权限.md","hash":"8b4e47b32c4a309296046a9522ec7ecdf3d258a1","modified":1676272160729},{"_id":"public/2019/10/23/MySQL创建用户并赋予权限/index.html","hash":"9bc393e2ad84f82361ad73c9c6a0636d942a179e","modified":1676273089002},{"_id":"public/archives/2019/index.html","hash":"053ceee65a1b89f052c266aa414971ffacbd8aa7","modified":1676273089002},{"_id":"public/archives/2019/10/index.html","hash":"8809c07804aabf5098a06a4f42390a8041f26fc6","modified":1676273089002},{"_id":"source/_posts/2021-04-06面试康美.md","hash":"a863d72b234e068fd2e84c069428b2b0171a0170","modified":1676272901193},{"_id":"source/_posts/2021-04-09面试一互.md","hash":"0a04f7f525729c98254852f5f547bd44e891c1cd","modified":1676272934161},{"_id":"source/_posts/2021-04-07面试华曦达.md","hash":"1164f83e4c904f1b3818433924e3554ffd2c9bf9","modified":1676272913611},{"_id":"source/_posts/2021-04-16面试木光.md","hash":"cb71fe6778994c0b26745e150f4bb460f76ca01d","modified":1676273009617},{"_id":"source/_posts/2021-04-14面试云集智造.md","hash":"304f546501b4f1b8dfab735a1d5ea449a735d01a","modified":1676272995751},{"_id":"source/_posts/2021-04-17面试嘉立创.md","hash":"0e2ef2878e0146958dbe962966baa7e36e9a4d75","modified":1676273027694},{"_id":"source/_posts/Redis分布式锁.md","hash":"a69f3204099c7452565de19b695b45ea468a7005","modified":1676273003093},{"_id":"source/_posts/SpringCloud开启DashBoard监控.md","hash":"b22c92e19e5960494da00419940bf75a5d3f58fb","modified":1676272954642},{"_id":"source/_posts/Spring代理那些事.md","hash":"254b5611a8ebdf7988f4a867c99853830a8ec51f","modified":1676272986804},{"_id":"source/_posts/Spring事务.md","hash":"7a2d2eb459ba1390944bac7e6d2e0aaa2dcc8591","modified":1676272974963},{"_id":"source/_posts/docker-compose-常用命令.md","hash":"38310ac42deb9bb29820c8b07e4bfc8ae48bc0b7","modified":1676272921972},{"_id":"source/_posts/服务熔断-降级.md","hash":"05e42a06bde007fe663c30adcb37d768ed333dfa","modified":1676272946355},{"_id":"source/_posts/将 MySQL 服务加入防火墙.md","hash":"6abf283ac3873fe0ba40091a9596bcf99aad7f1a","modified":1676272537749},{"_id":"source/_posts/杀死指定端口号进程.md","hash":"c1bfd4f579dcb53249d79f86cbb87cb9abc306a6","modified":1676272889209},{"_id":"source/_posts/模拟面试.md","hash":"087413efb1021cbe6d6df30c7a5a698d7e00c483","modified":1676272964656},{"_id":"public/2021/04/18/2021-04-17面试嘉立创/index.html","hash":"2461e94f07e34926a8cd09a64851978ba1fc6cba","modified":1676273089002},{"_id":"public/2021/04/18/2021-04-16面试木光/index.html","hash":"4b0732926ec222d7950df7c4cde0512f68409607","modified":1676273089002},{"_id":"public/2021/04/15/Redis分布式锁/index.html","hash":"7261b3e2646d789797cff98cf9effc20e7e9e1e7","modified":1676273089002},{"_id":"public/2021/04/15/2021-04-14面试云集智造/index.html","hash":"efaa29da9ffea66bcd4cf0ce9ffa522a2be60095","modified":1676273089002},{"_id":"public/2021/04/13/Spring代理那些事/index.html","hash":"790c7508d72926a37d5c0d70d24123849ff04936","modified":1676273089002},{"_id":"public/2021/04/11/模拟面试/index.html","hash":"a01294d4e1815f8f0912c0254d51058ce6abd4d7","modified":1676273089002},{"_id":"public/2021/04/11/SpringCloud开启DashBoard监控/index.html","hash":"8dda4c085961dd9c7056d7bfb6f629f3ad7e59c1","modified":1676273089002},{"_id":"public/2021/04/11/服务熔断-降级/index.html","hash":"6871c39c28d0fd43516b520bb35741abadcc86f3","modified":1676273089002},{"_id":"public/2021/04/09/2021-04-09面试一互/index.html","hash":"1553eb9abd1be7f024882b51690afc8d9bfc8a94","modified":1676273089002},{"_id":"public/2021/04/07/docker-compose-常用命令/index.html","hash":"1b0e0ef8272465cdadc804326f53f63c294d36dc","modified":1676273089002},{"_id":"public/2021/04/07/2021-04-07面试华曦达/index.html","hash":"3f4d06c5d6db13efa2e69b2972b1c5275d883e09","modified":1676273089002},{"_id":"public/2021/04/06/2021-04-06面试康美/index.html","hash":"3e72c7d728a1ecd0be5d0c8d048fd86fd618da2b","modified":1676273089002},{"_id":"public/2021/01/12/杀死指定端口号进程/index.html","hash":"33d5dc7d4b1400ae30a66061e09ca57dc17589cc","modified":1676273089002},{"_id":"public/2020/07/19/将 MySQL 服务加入防火墙/index.html","hash":"5b2cdaa9d305095f82455ea877a3b1b8eb8536cd","modified":1676273089002},{"_id":"public/archives/page/2/index.html","hash":"e1443cddef5f5361af3aef097a8a2ba984993467","modified":1676273089002},{"_id":"public/archives/2020/index.html","hash":"a9c4701eab729294701162b0ebdacdd0daec01ad","modified":1676273089002},{"_id":"public/archives/2020/07/index.html","hash":"b0dc2270ef8a95ca7e31355627dcd351e580c524","modified":1676273089002},{"_id":"public/archives/2021/index.html","hash":"d674af3d4eeceebd4bfdf671632ec1b8c6251c99","modified":1676273089002},{"_id":"public/archives/2021/page/2/index.html","hash":"f2a674242a28f7da492e73abfa13b28c77bab02a","modified":1676273089002},{"_id":"public/archives/2021/01/index.html","hash":"ba672bea1e9b35388d3af3e9d167c011e6cd78fd","modified":1676273089002},{"_id":"public/archives/2021/04/index.html","hash":"85390a4f6188cfb6d459fe526c1e256a3c6f32c2","modified":1676273089002},{"_id":"public/archives/2021/04/page/2/index.html","hash":"2b21c8302de52a46e663597bc826bdf617a47e50","modified":1676273089002},{"_id":"public/2021/04/12/Spring事务/index.html","hash":"1cb3ad39a0883674aa64df23b61eb1e097251a4e","modified":1676273089002},{"_id":"public/page/2/index.html","hash":"2ffa9591e97702c79ea61e3a5bb89c1f4b8e0d7a","modified":1676273089002}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-02-13T03:39:53.946Z","updated":"2023-02-13T03:39:53.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle29r29w0000mxejcszm8t0s","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"MySQL创建用户并赋予权限","date":"2019-10-23T08:15:18.000Z","_content":"CREATE USER 'username'@'localhost' IDENTIFIED BY 'password'; 创建用户\n\ngrant select,update on * to username identified by 'password'; 赋权\n\nFLUSH PRIVILEGES;（刷新权限）\n\n重启服务生效\n","source":"_posts/MySQL创建用户并赋予权限.md","raw":"---\ntitle: MySQL创建用户并赋予权限\ndate: 2019-10-23 16:15:18\ntags: \n---\nCREATE USER 'username'@'localhost' IDENTIFIED BY 'password'; 创建用户\n\ngrant select,update on * to username identified by 'password'; 赋权\n\nFLUSH PRIVILEGES;（刷新权限）\n\n重启服务生效\n","slug":"MySQL创建用户并赋予权限","published":1,"updated":"2023-02-13T07:09:20.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2ha5m90000lrej2pewdd03","content":"<p>CREATE USER ‘username‘@’localhost’ IDENTIFIED BY ‘password’; 创建用户</p>\n<p>grant select,update on * to username identified by ‘password’; 赋权</p>\n<p>FLUSH PRIVILEGES;（刷新权限）</p>\n<p>重启服务生效</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CREATE USER ‘username‘@’localhost’ IDENTIFIED BY ‘password’; 创建用户</p>\n<p>grant select,update on * to username identified by ‘password’; 赋权</p>\n<p>FLUSH PRIVILEGES;（刷新权限）</p>\n<p>重启服务生效</p>\n"},{"title":"2021/04/06面试康美","date":"2021-04-06T13:25:41.000Z","_content":"## 实现一个商品秒杀\n\n### 集合：\n删除元素的方法：Iterator的remove方法\njdk1.8自带的List.removeIf(obj -> 条件)\n\n### 设计模式：\n工厂模式\n观察者模式\n\n### Redis：\n缓存雪崩\n缓存击穿\n\n### MQ：\n多次失败重试\n\n\n### 事务传播：\nA方法调用B事务是否生效，cgib\n","source":"_posts/2021-04-06面试康美.md","raw":"---\ntitle: 2021/04/06面试康美\ndate: 2021-04-06 21:25:41\ntags:\n---\n## 实现一个商品秒杀\n\n### 集合：\n删除元素的方法：Iterator的remove方法\njdk1.8自带的List.removeIf(obj -> 条件)\n\n### 设计模式：\n工厂模式\n观察者模式\n\n### Redis：\n缓存雪崩\n缓存击穿\n\n### MQ：\n多次失败重试\n\n\n### 事务传播：\nA方法调用B事务是否生效，cgib\n","slug":"2021-04-06面试康美","published":1,"updated":"2023-02-13T07:21:41.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjg0000joejfi2y7i40","content":"<h2 id=\"实现一个商品秒杀\"><a href=\"#实现一个商品秒杀\" class=\"headerlink\" title=\"实现一个商品秒杀\"></a>实现一个商品秒杀</h2><h3 id=\"集合：\"><a href=\"#集合：\" class=\"headerlink\" title=\"集合：\"></a>集合：</h3><p>删除元素的方法：Iterator的remove方法<br>jdk1.8自带的List.removeIf(obj -&gt; 条件)</p>\n<h3 id=\"设计模式：\"><a href=\"#设计模式：\" class=\"headerlink\" title=\"设计模式：\"></a>设计模式：</h3><p>工厂模式<br>观察者模式</p>\n<h3 id=\"Redis：\"><a href=\"#Redis：\" class=\"headerlink\" title=\"Redis：\"></a>Redis：</h3><p>缓存雪崩<br>缓存击穿</p>\n<h3 id=\"MQ：\"><a href=\"#MQ：\" class=\"headerlink\" title=\"MQ：\"></a>MQ：</h3><p>多次失败重试</p>\n<h3 id=\"事务传播：\"><a href=\"#事务传播：\" class=\"headerlink\" title=\"事务传播：\"></a>事务传播：</h3><p>A方法调用B事务是否生效，cgib</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实现一个商品秒杀\"><a href=\"#实现一个商品秒杀\" class=\"headerlink\" title=\"实现一个商品秒杀\"></a>实现一个商品秒杀</h2><h3 id=\"集合：\"><a href=\"#集合：\" class=\"headerlink\" title=\"集合：\"></a>集合：</h3><p>删除元素的方法：Iterator的remove方法<br>jdk1.8自带的List.removeIf(obj -&gt; 条件)</p>\n<h3 id=\"设计模式：\"><a href=\"#设计模式：\" class=\"headerlink\" title=\"设计模式：\"></a>设计模式：</h3><p>工厂模式<br>观察者模式</p>\n<h3 id=\"Redis：\"><a href=\"#Redis：\" class=\"headerlink\" title=\"Redis：\"></a>Redis：</h3><p>缓存雪崩<br>缓存击穿</p>\n<h3 id=\"MQ：\"><a href=\"#MQ：\" class=\"headerlink\" title=\"MQ：\"></a>MQ：</h3><p>多次失败重试</p>\n<h3 id=\"事务传播：\"><a href=\"#事务传播：\" class=\"headerlink\" title=\"事务传播：\"></a>事务传播：</h3><p>A方法调用B事务是否生效，cgib</p>\n"},{"title":"2021/04/09面试一互","date":"2021-04-09T14:47:50.000Z","_content":"#### Spring事务\n\n- 事务传播级别\n\n- 同类里面调方法不事务会失效，不同的类则不会失效\n\n\n\n#### 数据库\n\n- 索引、避免或简化排序 、避免相关子查询  、不用in\n- 主键索引-聚簇索引-回表查询  联合索引\n\n#### Redis\n\n- set、setnx 分布式锁\n\n\n\n#### HashMap\n\n- 数据+链表/红黑树  resize tansfer 单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置\n\n\n\n#### 线程池核心参数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数\n                          int maximumPoolSize, // 线程池的最大线程数\n                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。\n                          TimeUnit unit, // keepAliveTime的时间单位\n                          ThreadFactory threadFactory, // 线程工厂\n                          BlockingQueue<Runnable> workQueue,// 用来储存等待执行任务的队列\n                          RejectedExecutionHandler handler // 拒绝策略\n                          ) \n```\n\n\n\n#### 微服务\n","source":"_posts/2021-04-09面试一互.md","raw":"---\ntitle: 2021/04/09面试一互\ndate: 2021-04-09 22:47:50\ntags:\n---\n#### Spring事务\n\n- 事务传播级别\n\n- 同类里面调方法不事务会失效，不同的类则不会失效\n\n\n\n#### 数据库\n\n- 索引、避免或简化排序 、避免相关子查询  、不用in\n- 主键索引-聚簇索引-回表查询  联合索引\n\n#### Redis\n\n- set、setnx 分布式锁\n\n\n\n#### HashMap\n\n- 数据+链表/红黑树  resize tansfer 单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置\n\n\n\n#### 线程池核心参数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数\n                          int maximumPoolSize, // 线程池的最大线程数\n                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。\n                          TimeUnit unit, // keepAliveTime的时间单位\n                          ThreadFactory threadFactory, // 线程工厂\n                          BlockingQueue<Runnable> workQueue,// 用来储存等待执行任务的队列\n                          RejectedExecutionHandler handler // 拒绝策略\n                          ) \n```\n\n\n\n#### 微服务\n","slug":"2021-04-09面试一互","published":1,"updated":"2023-02-13T07:22:14.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjj0001joej4hyn72xq","content":"<h4 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h4><ul>\n<li><p>事务传播级别</p>\n</li>\n<li><p>同类里面调方法不事务会失效，不同的类则不会失效</p>\n</li>\n</ul>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><ul>\n<li>索引、避免或简化排序 、避免相关子查询  、不用in</li>\n<li>主键索引-聚簇索引-回表查询  联合索引</li>\n</ul>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>set、setnx 分布式锁</li>\n</ul>\n<h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><ul>\n<li>数据+链表&#x2F;红黑树  resize tansfer 单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</li>\n</ul>\n<h4 id=\"线程池核心参数\"><a href=\"#线程池核心参数\" class=\"headerlink\" title=\"线程池核心参数\"></a>线程池核心参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数</span><br><span class=\"line\">                          int maximumPoolSize, // 线程池的最大线程数</span><br><span class=\"line\">                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。</span><br><span class=\"line\">                          TimeUnit unit, // keepAliveTime的时间单位</span><br><span class=\"line\">                          ThreadFactory threadFactory, // 线程工厂</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,// 用来储存等待执行任务的队列</span><br><span class=\"line\">                          RejectedExecutionHandler handler // 拒绝策略</span><br><span class=\"line\">                          ) </span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h4><ul>\n<li><p>事务传播级别</p>\n</li>\n<li><p>同类里面调方法不事务会失效，不同的类则不会失效</p>\n</li>\n</ul>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><ul>\n<li>索引、避免或简化排序 、避免相关子查询  、不用in</li>\n<li>主键索引-聚簇索引-回表查询  联合索引</li>\n</ul>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>set、setnx 分布式锁</li>\n</ul>\n<h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><ul>\n<li>数据+链表&#x2F;红黑树  resize tansfer 单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</li>\n</ul>\n<h4 id=\"线程池核心参数\"><a href=\"#线程池核心参数\" class=\"headerlink\" title=\"线程池核心参数\"></a>线程池核心参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数</span><br><span class=\"line\">                          int maximumPoolSize, // 线程池的最大线程数</span><br><span class=\"line\">                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。</span><br><span class=\"line\">                          TimeUnit unit, // keepAliveTime的时间单位</span><br><span class=\"line\">                          ThreadFactory threadFactory, // 线程工厂</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,// 用来储存等待执行任务的队列</span><br><span class=\"line\">                          RejectedExecutionHandler handler // 拒绝策略</span><br><span class=\"line\">                          ) </span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4>"},{"title":"2021/04/07面试华曦达","date":"2021-04-07T09:12:26.000Z","_content":"### Java基础：\nString 不可变 StringBuffer 可变\n\nHashMap HashTable 覆盖key null值key  线程安全 数组+链表/红黑树\n\nIO常用类\nOutputStream、InputStream、FileInputStream、Buffed、FileReader\n\n线程\nwait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。\n进入wait状态的线程能够被notify和notifyAll线程唤醒，并且会释放实例对象所持有的锁。sleep不会被唤醒，也不会释放锁。\nJava中的wait方法应在同步代码块中调用，sleep则没要求。\n\nsynchronized 在方法和类上的区别\n如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。\n如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。\n\n线程池使用：ThreadPoolExecutor\ncorePoolSize 为线程池的基本大小。\nmaximumPoolSize 为线程池最大线程大小。\nkeepAliveTime 和 unit 则是线程空闲后的存活时间。\nworkQueue 用于存放任务的阻塞队列。\nhandler 当队列和最大线程池都满了之后的饱和策略。\nSpringBoot使用\n配置\n```\n@Configuration\npublic class TreadPoolConfig {\n    /**\n     * 消费队列线程\n     * @return\n     */\n    @Bean(value = \"consumerQueueThreadPool\")\n    public ExecutorService buildConsumerQueueThreadPool(){\n        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()\n                .setNameFormat(\"consumer-queue-thread-%d\").build();\n        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());\n        return pool ;\n    }\n}\n```\n使用\n```\n@Resource(name = \"consumerQueueThreadPool\")\nprivate ExecutorService consumerQueueThreadPool;\n@Override\npublic void execute() {\n    //消费队列\n    for (int i = 0; i < 5; i++) {\n        consumerQueueThreadPool.execute(new ConsumerQueueThread());\n    }\n}\n```\n\n静态资源初始化时间 ：静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的\n\nServlet初始化 ：可以配置类加载初始化，默认调用时被初始化\n\nServlet生命周期：实例化- ->初始化- ->执行处理- ->销毁\n\n### 框架\n#### RabbitMQ：\nProducer： 消息生产者，就是投递消息的程序\nConsumer： 消息消费者，就是接受消息的程序\nChannel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务\n\n#### Redis\n\n\n#### SpringBoot\n\n\n返回json xml produces = { \"application/xml;charset=UTF-8\" })\n\n国际化\n\n\n#### Docker\n获取镜像：docker pull \n查看镜像：docker images\n查看镜像体积：docker system df \n删除镜像 ： docker rmi 镜像名称或镜像id\n虚悬镜像：查看镜像 docker images \n显示正在运行的容器：docker ps \n显示所有容器，包括运行和没有运行的 : docker ps -a\n<none> 为无效镜像，虚悬镜像\n删除虚悬镜像：docker image prune\n中间层镜像：docker images ls -a  查看所有的镜像\n     中间层镜像是 镜像本身以来的其他镜像，只不过么有显示依赖镜像的名称，不能删除\n     例如tomcat:  tomcat 镜像依赖于jar镜像，但是在显示镜像的时候，jar镜像的名称并没有显示jar，而是显示的<none> ，这样的镜像被称为中间层镜像，不能删除中间层镜像；\n\n启动容器：docker run  -p 8080(宿主机端口):8080(容器端口)\ndocker run -p 8080:8080 --name tomcatname -d tomcat\n dokcer运行 端口做映射， 启动一个名称叫做tomcatname 的容器，以tomcat 镜像\n 停止容器：docker stop 容器名称或容器ip\n 删除容器：docker rm 容器名称或容器id\n 强制删除容器：docker rm -f 容器名称或id\n启动之前停止的容器：docker start  容器id\n删除停止的容器：docker rm 容器名称或id\n删除所有的停止的容器：  docker container prune\nhttps: 默认的端口是443，ssl连接 \nhttp：默认端口是80\n交互式进入容器内部：\ndocker exec -it  容器名称或id /bin/bash\n/bin/bash ,使用shell执行命令\n\n### Linux 常用命令\nlsot -i:port 、ps -ef|grep xxx、tail -f xxx、more 、cat\n\n\n### SQL查询慢定位问题\n查询执行计划 EXPLAIN慢查询日志里出现的SELECT查询\nexplain列的解释\ntable：显示这一行的数据是关于哪张表的\ntype：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index、all\npossible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句\nkey： 实际使用的索引。如果为null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引。这种情况下，可以在select语句中使用use index(indexname)来强制使用一个索引或者用ignore index(indexname)来强制mysql忽略索引\nkey_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好\nref：显示索引的哪一列被使用了，如果可能的话，是一个常数\nrows：mysql认为必须检查的用来返回请求数据的行数\nextra：关于mysql如何解析查询的额外信息。例子:using temporary和using filesort，意思mysql根本不能使用索引，结果是检索会很慢\n\n### 深刻的问题\nstatic类注入 PostConstruct Spring生命周期\n","source":"_posts/2021-04-07面试华曦达.md","raw":"---\ntitle: 2021/04/07面试华曦达\ndate: 2021-04-07 17:12:26\ntags:\n---\n### Java基础：\nString 不可变 StringBuffer 可变\n\nHashMap HashTable 覆盖key null值key  线程安全 数组+链表/红黑树\n\nIO常用类\nOutputStream、InputStream、FileInputStream、Buffed、FileReader\n\n线程\nwait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。\n进入wait状态的线程能够被notify和notifyAll线程唤醒，并且会释放实例对象所持有的锁。sleep不会被唤醒，也不会释放锁。\nJava中的wait方法应在同步代码块中调用，sleep则没要求。\n\nsynchronized 在方法和类上的区别\n如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。\n如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。\n\n线程池使用：ThreadPoolExecutor\ncorePoolSize 为线程池的基本大小。\nmaximumPoolSize 为线程池最大线程大小。\nkeepAliveTime 和 unit 则是线程空闲后的存活时间。\nworkQueue 用于存放任务的阻塞队列。\nhandler 当队列和最大线程池都满了之后的饱和策略。\nSpringBoot使用\n配置\n```\n@Configuration\npublic class TreadPoolConfig {\n    /**\n     * 消费队列线程\n     * @return\n     */\n    @Bean(value = \"consumerQueueThreadPool\")\n    public ExecutorService buildConsumerQueueThreadPool(){\n        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()\n                .setNameFormat(\"consumer-queue-thread-%d\").build();\n        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());\n        return pool ;\n    }\n}\n```\n使用\n```\n@Resource(name = \"consumerQueueThreadPool\")\nprivate ExecutorService consumerQueueThreadPool;\n@Override\npublic void execute() {\n    //消费队列\n    for (int i = 0; i < 5; i++) {\n        consumerQueueThreadPool.execute(new ConsumerQueueThread());\n    }\n}\n```\n\n静态资源初始化时间 ：静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的\n\nServlet初始化 ：可以配置类加载初始化，默认调用时被初始化\n\nServlet生命周期：实例化- ->初始化- ->执行处理- ->销毁\n\n### 框架\n#### RabbitMQ：\nProducer： 消息生产者，就是投递消息的程序\nConsumer： 消息消费者，就是接受消息的程序\nChannel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务\n\n#### Redis\n\n\n#### SpringBoot\n\n\n返回json xml produces = { \"application/xml;charset=UTF-8\" })\n\n国际化\n\n\n#### Docker\n获取镜像：docker pull \n查看镜像：docker images\n查看镜像体积：docker system df \n删除镜像 ： docker rmi 镜像名称或镜像id\n虚悬镜像：查看镜像 docker images \n显示正在运行的容器：docker ps \n显示所有容器，包括运行和没有运行的 : docker ps -a\n<none> 为无效镜像，虚悬镜像\n删除虚悬镜像：docker image prune\n中间层镜像：docker images ls -a  查看所有的镜像\n     中间层镜像是 镜像本身以来的其他镜像，只不过么有显示依赖镜像的名称，不能删除\n     例如tomcat:  tomcat 镜像依赖于jar镜像，但是在显示镜像的时候，jar镜像的名称并没有显示jar，而是显示的<none> ，这样的镜像被称为中间层镜像，不能删除中间层镜像；\n\n启动容器：docker run  -p 8080(宿主机端口):8080(容器端口)\ndocker run -p 8080:8080 --name tomcatname -d tomcat\n dokcer运行 端口做映射， 启动一个名称叫做tomcatname 的容器，以tomcat 镜像\n 停止容器：docker stop 容器名称或容器ip\n 删除容器：docker rm 容器名称或容器id\n 强制删除容器：docker rm -f 容器名称或id\n启动之前停止的容器：docker start  容器id\n删除停止的容器：docker rm 容器名称或id\n删除所有的停止的容器：  docker container prune\nhttps: 默认的端口是443，ssl连接 \nhttp：默认端口是80\n交互式进入容器内部：\ndocker exec -it  容器名称或id /bin/bash\n/bin/bash ,使用shell执行命令\n\n### Linux 常用命令\nlsot -i:port 、ps -ef|grep xxx、tail -f xxx、more 、cat\n\n\n### SQL查询慢定位问题\n查询执行计划 EXPLAIN慢查询日志里出现的SELECT查询\nexplain列的解释\ntable：显示这一行的数据是关于哪张表的\ntype：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index、all\npossible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句\nkey： 实际使用的索引。如果为null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引。这种情况下，可以在select语句中使用use index(indexname)来强制使用一个索引或者用ignore index(indexname)来强制mysql忽略索引\nkey_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好\nref：显示索引的哪一列被使用了，如果可能的话，是一个常数\nrows：mysql认为必须检查的用来返回请求数据的行数\nextra：关于mysql如何解析查询的额外信息。例子:using temporary和using filesort，意思mysql根本不能使用索引，结果是检索会很慢\n\n### 深刻的问题\nstatic类注入 PostConstruct Spring生命周期\n","slug":"2021-04-07面试华曦达","published":1,"updated":"2023-02-13T07:21:53.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjk0002joej2k7tb0ke","content":"<h3 id=\"Java基础：\"><a href=\"#Java基础：\" class=\"headerlink\" title=\"Java基础：\"></a>Java基础：</h3><p>String 不可变 StringBuffer 可变</p>\n<p>HashMap HashTable 覆盖key null值key  线程安全 数组+链表&#x2F;红黑树</p>\n<p>IO常用类<br>OutputStream、InputStream、FileInputStream、Buffed、FileReader</p>\n<p>线程<br>wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。<br>进入wait状态的线程能够被notify和notifyAll线程唤醒，并且会释放实例对象所持有的锁。sleep不会被唤醒，也不会释放锁。<br>Java中的wait方法应在同步代码块中调用，sleep则没要求。</p>\n<p>synchronized 在方法和类上的区别<br>如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。<br>如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。</p>\n<p>线程池使用：ThreadPoolExecutor<br>corePoolSize 为线程池的基本大小。<br>maximumPoolSize 为线程池最大线程大小。<br>keepAliveTime 和 unit 则是线程空闲后的存活时间。<br>workQueue 用于存放任务的阻塞队列。<br>handler 当队列和最大线程池都满了之后的饱和策略。<br>SpringBoot使用<br>配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class TreadPoolConfig &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 消费队列线程</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(value = &quot;consumerQueueThreadPool&quot;)</span><br><span class=\"line\">    public ExecutorService buildConsumerQueueThreadPool()&#123;</span><br><span class=\"line\">        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class=\"line\">                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();</span><br><span class=\"line\">        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\">        return pool ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource(name = &quot;consumerQueueThreadPool&quot;)</span><br><span class=\"line\">private ExecutorService consumerQueueThreadPool;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void execute() &#123;</span><br><span class=\"line\">    //消费队列</span><br><span class=\"line\">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">        consumerQueueThreadPool.execute(new ConsumerQueueThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态资源初始化时间 ：静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</p>\n<p>Servlet初始化 ：可以配置类加载初始化，默认调用时被初始化</p>\n<p>Servlet生命周期：实例化- -&gt;初始化- -&gt;执行处理- -&gt;销毁</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><h4 id=\"RabbitMQ：\"><a href=\"#RabbitMQ：\" class=\"headerlink\" title=\"RabbitMQ：\"></a>RabbitMQ：</h4><p>Producer： 消息生产者，就是投递消息的程序<br>Consumer： 消息消费者，就是接受消息的程序<br>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</p>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><h4 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h4><p>返回json xml produces &#x3D; { “application&#x2F;xml;charset&#x3D;UTF-8” })</p>\n<p>国际化</p>\n<h4 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h4><p>获取镜像：docker pull <br>查看镜像：docker images<br>查看镜像体积：docker system df <br>删除镜像 ： docker rmi 镜像名称或镜像id<br>虚悬镜像：查看镜像 docker images <br>显示正在运行的容器：docker ps <br>显示所有容器，包括运行和没有运行的 : docker ps -a<br><none> 为无效镜像，虚悬镜像<br>删除虚悬镜像：docker image prune<br>中间层镜像：docker images ls -a  查看所有的镜像<br>     中间层镜像是 镜像本身以来的其他镜像，只不过么有显示依赖镜像的名称，不能删除<br>     例如tomcat:  tomcat 镜像依赖于jar镜像，但是在显示镜像的时候，jar镜像的名称并没有显示jar，而是显示的<none> ，这样的镜像被称为中间层镜像，不能删除中间层镜像；</p>\n<p>启动容器：docker run  -p 8080(宿主机端口):8080(容器端口)<br>docker run -p 8080:8080 –name tomcatname -d tomcat<br> dokcer运行 端口做映射， 启动一个名称叫做tomcatname 的容器，以tomcat 镜像<br> 停止容器：docker stop 容器名称或容器ip<br> 删除容器：docker rm 容器名称或容器id<br> 强制删除容器：docker rm -f 容器名称或id<br>启动之前停止的容器：docker start  容器id<br>删除停止的容器：docker rm 容器名称或id<br>删除所有的停止的容器：  docker container prune<br>https: 默认的端口是443，ssl连接 <br>http：默认端口是80<br>交互式进入容器内部：<br>docker exec -it  容器名称或id &#x2F;bin&#x2F;bash<br>&#x2F;bin&#x2F;bash ,使用shell执行命令</p>\n<h3 id=\"Linux-常用命令\"><a href=\"#Linux-常用命令\" class=\"headerlink\" title=\"Linux 常用命令\"></a>Linux 常用命令</h3><p>lsot -i:port 、ps -ef|grep xxx、tail -f xxx、more 、cat</p>\n<h3 id=\"SQL查询慢定位问题\"><a href=\"#SQL查询慢定位问题\" class=\"headerlink\" title=\"SQL查询慢定位问题\"></a>SQL查询慢定位问题</h3><p>查询执行计划 EXPLAIN慢查询日志里出现的SELECT查询<br>explain列的解释<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index、all<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句<br>key： 实际使用的索引。如果为null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引。这种情况下，可以在select语句中使用use index(indexname)来强制使用一个索引或者用ignore index(indexname)来强制mysql忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：mysql认为必须检查的用来返回请求数据的行数<br>extra：关于mysql如何解析查询的额外信息。例子:using temporary和using filesort，意思mysql根本不能使用索引，结果是检索会很慢</p>\n<h3 id=\"深刻的问题\"><a href=\"#深刻的问题\" class=\"headerlink\" title=\"深刻的问题\"></a>深刻的问题</h3><p>static类注入 PostConstruct Spring生命周期</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Java基础：\"><a href=\"#Java基础：\" class=\"headerlink\" title=\"Java基础：\"></a>Java基础：</h3><p>String 不可变 StringBuffer 可变</p>\n<p>HashMap HashTable 覆盖key null值key  线程安全 数组+链表&#x2F;红黑树</p>\n<p>IO常用类<br>OutputStream、InputStream、FileInputStream、Buffed、FileReader</p>\n<p>线程<br>wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。<br>进入wait状态的线程能够被notify和notifyAll线程唤醒，并且会释放实例对象所持有的锁。sleep不会被唤醒，也不会释放锁。<br>Java中的wait方法应在同步代码块中调用，sleep则没要求。</p>\n<p>synchronized 在方法和类上的区别<br>如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。<br>如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。</p>\n<p>线程池使用：ThreadPoolExecutor<br>corePoolSize 为线程池的基本大小。<br>maximumPoolSize 为线程池最大线程大小。<br>keepAliveTime 和 unit 则是线程空闲后的存活时间。<br>workQueue 用于存放任务的阻塞队列。<br>handler 当队列和最大线程池都满了之后的饱和策略。<br>SpringBoot使用<br>配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class TreadPoolConfig &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 消费队列线程</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(value = &quot;consumerQueueThreadPool&quot;)</span><br><span class=\"line\">    public ExecutorService buildConsumerQueueThreadPool()&#123;</span><br><span class=\"line\">        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class=\"line\">                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();</span><br><span class=\"line\">        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\">        return pool ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource(name = &quot;consumerQueueThreadPool&quot;)</span><br><span class=\"line\">private ExecutorService consumerQueueThreadPool;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void execute() &#123;</span><br><span class=\"line\">    //消费队列</span><br><span class=\"line\">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">        consumerQueueThreadPool.execute(new ConsumerQueueThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态资源初始化时间 ：静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</p>\n<p>Servlet初始化 ：可以配置类加载初始化，默认调用时被初始化</p>\n<p>Servlet生命周期：实例化- -&gt;初始化- -&gt;执行处理- -&gt;销毁</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><h4 id=\"RabbitMQ：\"><a href=\"#RabbitMQ：\" class=\"headerlink\" title=\"RabbitMQ：\"></a>RabbitMQ：</h4><p>Producer： 消息生产者，就是投递消息的程序<br>Consumer： 消息消费者，就是接受消息的程序<br>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</p>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><h4 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h4><p>返回json xml produces &#x3D; { “application&#x2F;xml;charset&#x3D;UTF-8” })</p>\n<p>国际化</p>\n<h4 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h4><p>获取镜像：docker pull <br>查看镜像：docker images<br>查看镜像体积：docker system df <br>删除镜像 ： docker rmi 镜像名称或镜像id<br>虚悬镜像：查看镜像 docker images <br>显示正在运行的容器：docker ps <br>显示所有容器，包括运行和没有运行的 : docker ps -a<br><none> 为无效镜像，虚悬镜像<br>删除虚悬镜像：docker image prune<br>中间层镜像：docker images ls -a  查看所有的镜像<br>     中间层镜像是 镜像本身以来的其他镜像，只不过么有显示依赖镜像的名称，不能删除<br>     例如tomcat:  tomcat 镜像依赖于jar镜像，但是在显示镜像的时候，jar镜像的名称并没有显示jar，而是显示的<none> ，这样的镜像被称为中间层镜像，不能删除中间层镜像；</p>\n<p>启动容器：docker run  -p 8080(宿主机端口):8080(容器端口)<br>docker run -p 8080:8080 –name tomcatname -d tomcat<br> dokcer运行 端口做映射， 启动一个名称叫做tomcatname 的容器，以tomcat 镜像<br> 停止容器：docker stop 容器名称或容器ip<br> 删除容器：docker rm 容器名称或容器id<br> 强制删除容器：docker rm -f 容器名称或id<br>启动之前停止的容器：docker start  容器id<br>删除停止的容器：docker rm 容器名称或id<br>删除所有的停止的容器：  docker container prune<br>https: 默认的端口是443，ssl连接 <br>http：默认端口是80<br>交互式进入容器内部：<br>docker exec -it  容器名称或id &#x2F;bin&#x2F;bash<br>&#x2F;bin&#x2F;bash ,使用shell执行命令</p>\n<h3 id=\"Linux-常用命令\"><a href=\"#Linux-常用命令\" class=\"headerlink\" title=\"Linux 常用命令\"></a>Linux 常用命令</h3><p>lsot -i:port 、ps -ef|grep xxx、tail -f xxx、more 、cat</p>\n<h3 id=\"SQL查询慢定位问题\"><a href=\"#SQL查询慢定位问题\" class=\"headerlink\" title=\"SQL查询慢定位问题\"></a>SQL查询慢定位问题</h3><p>查询执行计划 EXPLAIN慢查询日志里出现的SELECT查询<br>explain列的解释<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index、all<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从where语句中选择一个合适的语句<br>key： 实际使用的索引。如果为null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引。这种情况下，可以在select语句中使用use index(indexname)来强制使用一个索引或者用ignore index(indexname)来强制mysql忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：mysql认为必须检查的用来返回请求数据的行数<br>extra：关于mysql如何解析查询的额外信息。例子:using temporary和using filesort，意思mysql根本不能使用索引，结果是检索会很慢</p>\n<h3 id=\"深刻的问题\"><a href=\"#深刻的问题\" class=\"headerlink\" title=\"深刻的问题\"></a>深刻的问题</h3><p>static类注入 PostConstruct Spring生命周期</p>\n"},{"title":"2021/04/16面试木光","date":"2021-04-18T05:46:44.000Z","_content":"**WebSocket使用**\n\n```javascript\nonopen \nonmessage \nonclose \n```\n\n```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\n \n  \n@ServerEndpoint(\"/hello\")\npublic class HelloWorldEndpoint {\n \n     \n    @OnMessage\n    public String hello(String message) {\n        System.out.println(\"Received : \"+ message);\n        return message;\n    }\n \n    @OnOpen\n    public void myOnOpen(Session session) {\n        System.out.println(\"WebSocket opened: \" + session.getId());\n    }\n \n    @OnClose\n    public void myOnClose(CloseReason reason) {\n        System.out.println(\"Closing a WebSocket due to \" + reason.getReasonPhrase());\n    }\n \n}\n```\n\n**Linux根据进程号查找端口号**\n\nnetstat -nap |grep pid\n\n**原生提供接口**\n\n使用javax.ws.rs包下的@Path和@Post@Get\n\nServlet\n\n**war包目录**\n\nWEB-INF\n\n​\t-classes\n\n​\t-lib\n\n**如何访问web-inf下的jsp文件**\n\n接口中直接return文件名（转发）\n\n**重定向和转发区别**\n\n转发是服务器行为，重定向是客户端行为。\n\n**Session和Cookie**\n\n**什么是 Cookie**\n\nHTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n**什么是 Session**\n\nSession 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。\n\n**Dubbo提供的RPC协议**\n\ndubbo、rmi、hessian、http、webservice、thrift、redis\n\n**线程创建方式**\n\nThread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）\n\n**设置线程超时中断（使用Future）**\n\n```java\nfinal ExecutorService exec = Executors.newFixedThreadPool(1);\nFuture<Object> future = exec.submit(() -> {\n    for (int i = 1; i <= 1000; i++) {\n        System.out.println(i + \"\");\n        Thread.sleep(1000L);\n    }\n    return null;\n});\ntry {\n    future.get(3000, TimeUnit.MILLISECONDS);\n} catch (Exception e) {\n    e.printStackTrace();\n    future.cancel(true);//必须代码\n}\nSystem.out.println(\"end\");\n```\n","source":"_posts/2021-04-16面试木光.md","raw":"---\ntitle: 2021/04/16面试木光\ndate: 2021-04-18 13:46:44\ntags:\n---\n**WebSocket使用**\n\n```javascript\nonopen \nonmessage \nonclose \n```\n\n```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\n \n  \n@ServerEndpoint(\"/hello\")\npublic class HelloWorldEndpoint {\n \n     \n    @OnMessage\n    public String hello(String message) {\n        System.out.println(\"Received : \"+ message);\n        return message;\n    }\n \n    @OnOpen\n    public void myOnOpen(Session session) {\n        System.out.println(\"WebSocket opened: \" + session.getId());\n    }\n \n    @OnClose\n    public void myOnClose(CloseReason reason) {\n        System.out.println(\"Closing a WebSocket due to \" + reason.getReasonPhrase());\n    }\n \n}\n```\n\n**Linux根据进程号查找端口号**\n\nnetstat -nap |grep pid\n\n**原生提供接口**\n\n使用javax.ws.rs包下的@Path和@Post@Get\n\nServlet\n\n**war包目录**\n\nWEB-INF\n\n​\t-classes\n\n​\t-lib\n\n**如何访问web-inf下的jsp文件**\n\n接口中直接return文件名（转发）\n\n**重定向和转发区别**\n\n转发是服务器行为，重定向是客户端行为。\n\n**Session和Cookie**\n\n**什么是 Cookie**\n\nHTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n**什么是 Session**\n\nSession 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。\n\n**Dubbo提供的RPC协议**\n\ndubbo、rmi、hessian、http、webservice、thrift、redis\n\n**线程创建方式**\n\nThread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）\n\n**设置线程超时中断（使用Future）**\n\n```java\nfinal ExecutorService exec = Executors.newFixedThreadPool(1);\nFuture<Object> future = exec.submit(() -> {\n    for (int i = 1; i <= 1000; i++) {\n        System.out.println(i + \"\");\n        Thread.sleep(1000L);\n    }\n    return null;\n});\ntry {\n    future.get(3000, TimeUnit.MILLISECONDS);\n} catch (Exception e) {\n    e.printStackTrace();\n    future.cancel(true);//必须代码\n}\nSystem.out.println(\"end\");\n```\n","slug":"2021-04-16面试木光","published":1,"updated":"2023-02-13T07:23:29.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjl0003joej2tb62sgw","content":"<p><strong>WebSocket使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onopen </span><br><span class=\"line\">onmessage </span><br><span class=\"line\">onclose </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.websocket.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class=\"line\"> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@ServerEndpoint(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldEndpoint</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"meta\">@OnMessage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Received : &quot;</span>+ message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OnOpen</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myOnOpen</span><span class=\"params\">(Session session)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;WebSocket opened: &quot;</span> + session.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OnClose</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myOnClose</span><span class=\"params\">(CloseReason reason)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Closing a WebSocket due to &quot;</span> + reason.getReasonPhrase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Linux根据进程号查找端口号</strong></p>\n<p>netstat -nap |grep pid</p>\n<p><strong>原生提供接口</strong></p>\n<p>使用javax.ws.rs包下的@Path和@Post@Get</p>\n<p>Servlet</p>\n<p><strong>war包目录</strong></p>\n<p>WEB-INF</p>\n<p>​\t-classes</p>\n<p>​\t-lib</p>\n<p><strong>如何访问web-inf下的jsp文件</strong></p>\n<p>接口中直接return文件名（转发）</p>\n<p><strong>重定向和转发区别</strong></p>\n<p>转发是服务器行为，重定向是客户端行为。</p>\n<p><strong>Session和Cookie</strong></p>\n<p><strong>什么是 Cookie</strong></p>\n<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><strong>什么是 Session</strong></p>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n<p><strong>Dubbo提供的RPC协议</strong></p>\n<p>dubbo、rmi、hessian、http、webservice、thrift、redis</p>\n<p><strong>线程创建方式</strong></p>\n<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>\n<p><strong>设置线程超时中断（使用Future）</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">exec</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\">Future&lt;Object&gt; future = exec.submit(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">        System.out.println(i + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    future.get(<span class=\"number\">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    future.cancel(<span class=\"literal\">true</span>);<span class=\"comment\">//必须代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>WebSocket使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onopen </span><br><span class=\"line\">onmessage </span><br><span class=\"line\">onclose </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.websocket.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class=\"line\"> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@ServerEndpoint(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldEndpoint</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"meta\">@OnMessage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Received : &quot;</span>+ message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OnOpen</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myOnOpen</span><span class=\"params\">(Session session)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;WebSocket opened: &quot;</span> + session.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OnClose</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myOnClose</span><span class=\"params\">(CloseReason reason)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Closing a WebSocket due to &quot;</span> + reason.getReasonPhrase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Linux根据进程号查找端口号</strong></p>\n<p>netstat -nap |grep pid</p>\n<p><strong>原生提供接口</strong></p>\n<p>使用javax.ws.rs包下的@Path和@Post@Get</p>\n<p>Servlet</p>\n<p><strong>war包目录</strong></p>\n<p>WEB-INF</p>\n<p>​\t-classes</p>\n<p>​\t-lib</p>\n<p><strong>如何访问web-inf下的jsp文件</strong></p>\n<p>接口中直接return文件名（转发）</p>\n<p><strong>重定向和转发区别</strong></p>\n<p>转发是服务器行为，重定向是客户端行为。</p>\n<p><strong>Session和Cookie</strong></p>\n<p><strong>什么是 Cookie</strong></p>\n<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><strong>什么是 Session</strong></p>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n<p><strong>Dubbo提供的RPC协议</strong></p>\n<p>dubbo、rmi、hessian、http、webservice、thrift、redis</p>\n<p><strong>线程创建方式</strong></p>\n<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>\n<p><strong>设置线程超时中断（使用Future）</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">exec</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\">Future&lt;Object&gt; future = exec.submit(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">        System.out.println(i + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    future.get(<span class=\"number\">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    future.cancel(<span class=\"literal\">true</span>);<span class=\"comment\">//必须代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"2021/04/14面试云集智造","date":"2021-04-15T08:17:38.000Z","_content":"#### 个人技术评估\n\n- 对源码的了解\n\n\n\n#### 基础与框架\n\n- Integer：缓存了从-128到127之间的所有的整数对象，自动装箱调用方法Integer的intValue方法\n\n- 自定义配置项 @Value ，@Configration\n\n- Redis数据类型 String、List、Hash、Set、SortedSet\n\n- Redis设置过期时间：set后expire 或set(key, value, \"NX\", \"EX\", expireSecond); 命令 `set key value ex 100 nx ` redistemplate\n\n  ```\n  redisTemplate.opsForValue().set(codeKey, code, 20, TimeUnit.SECONDS);\n  ```\n\n- Spring 模式单例 @Scope(\"prototype\")\n\n- @Controller单线程还是多线程： 单例多线程\n\n- mysql连接字符串concat(str1,str2)\n\n- 主表字段更新到子表 update b letf join a on a.id = b.pid set col1 = a.col1\n\n- 设计分布式编码生成规则\n\n- RabbitMQ消息幂等 全局ID判断是否存在 ，后需考虑何时删除\n\n\n\n#### 加强分布式和微服务\n","source":"_posts/2021-04-14面试云集智造.md","raw":"---\ntitle: 2021/04/14面试云集智造\ndate: 2021-04-15 16:17:38\ntags:\n---\n#### 个人技术评估\n\n- 对源码的了解\n\n\n\n#### 基础与框架\n\n- Integer：缓存了从-128到127之间的所有的整数对象，自动装箱调用方法Integer的intValue方法\n\n- 自定义配置项 @Value ，@Configration\n\n- Redis数据类型 String、List、Hash、Set、SortedSet\n\n- Redis设置过期时间：set后expire 或set(key, value, \"NX\", \"EX\", expireSecond); 命令 `set key value ex 100 nx ` redistemplate\n\n  ```\n  redisTemplate.opsForValue().set(codeKey, code, 20, TimeUnit.SECONDS);\n  ```\n\n- Spring 模式单例 @Scope(\"prototype\")\n\n- @Controller单线程还是多线程： 单例多线程\n\n- mysql连接字符串concat(str1,str2)\n\n- 主表字段更新到子表 update b letf join a on a.id = b.pid set col1 = a.col1\n\n- 设计分布式编码生成规则\n\n- RabbitMQ消息幂等 全局ID判断是否存在 ，后需考虑何时删除\n\n\n\n#### 加强分布式和微服务\n","slug":"2021-04-14面试云集智造","published":1,"updated":"2023-02-13T07:23:15.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjm0004joejhlut0od4","content":"<h4 id=\"个人技术评估\"><a href=\"#个人技术评估\" class=\"headerlink\" title=\"个人技术评估\"></a>个人技术评估</h4><ul>\n<li>对源码的了解</li>\n</ul>\n<h4 id=\"基础与框架\"><a href=\"#基础与框架\" class=\"headerlink\" title=\"基础与框架\"></a>基础与框架</h4><ul>\n<li><p>Integer：缓存了从-128到127之间的所有的整数对象，自动装箱调用方法Integer的intValue方法</p>\n</li>\n<li><p>自定义配置项 @Value ，@Configration</p>\n</li>\n<li><p>Redis数据类型 String、List、Hash、Set、SortedSet</p>\n</li>\n<li><p>Redis设置过期时间：set后expire 或set(key, value, “NX”, “EX”, expireSecond); 命令 <code>set key value ex 100 nx </code> redistemplate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redisTemplate.opsForValue().set(codeKey, code, 20, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Spring 模式单例 @Scope(“prototype”)</p>\n</li>\n<li><p>@Controller单线程还是多线程： 单例多线程</p>\n</li>\n<li><p>mysql连接字符串concat(str1,str2)</p>\n</li>\n<li><p>主表字段更新到子表 update b letf join a on a.id &#x3D; b.pid set col1 &#x3D; a.col1</p>\n</li>\n<li><p>设计分布式编码生成规则</p>\n</li>\n<li><p>RabbitMQ消息幂等 全局ID判断是否存在 ，后需考虑何时删除</p>\n</li>\n</ul>\n<h4 id=\"加强分布式和微服务\"><a href=\"#加强分布式和微服务\" class=\"headerlink\" title=\"加强分布式和微服务\"></a>加强分布式和微服务</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"个人技术评估\"><a href=\"#个人技术评估\" class=\"headerlink\" title=\"个人技术评估\"></a>个人技术评估</h4><ul>\n<li>对源码的了解</li>\n</ul>\n<h4 id=\"基础与框架\"><a href=\"#基础与框架\" class=\"headerlink\" title=\"基础与框架\"></a>基础与框架</h4><ul>\n<li><p>Integer：缓存了从-128到127之间的所有的整数对象，自动装箱调用方法Integer的intValue方法</p>\n</li>\n<li><p>自定义配置项 @Value ，@Configration</p>\n</li>\n<li><p>Redis数据类型 String、List、Hash、Set、SortedSet</p>\n</li>\n<li><p>Redis设置过期时间：set后expire 或set(key, value, “NX”, “EX”, expireSecond); 命令 <code>set key value ex 100 nx </code> redistemplate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redisTemplate.opsForValue().set(codeKey, code, 20, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Spring 模式单例 @Scope(“prototype”)</p>\n</li>\n<li><p>@Controller单线程还是多线程： 单例多线程</p>\n</li>\n<li><p>mysql连接字符串concat(str1,str2)</p>\n</li>\n<li><p>主表字段更新到子表 update b letf join a on a.id &#x3D; b.pid set col1 &#x3D; a.col1</p>\n</li>\n<li><p>设计分布式编码生成规则</p>\n</li>\n<li><p>RabbitMQ消息幂等 全局ID判断是否存在 ，后需考虑何时删除</p>\n</li>\n</ul>\n<h4 id=\"加强分布式和微服务\"><a href=\"#加强分布式和微服务\" class=\"headerlink\" title=\"加强分布式和微服务\"></a>加强分布式和微服务</h4>"},{"title":"2021/04/17面试嘉立创","date":"2021-04-18T05:47:01.000Z","_content":"**Oracle 数据类型：**\n\n- 字符串类型 char nchar varchar nvarchar2\n- 数字类型 number integer\n- 日期类型 date TIMESTAMP\n- LOB类型 BLOB二进制 CLOB大文本\n\n**Redis 数据类型**：String、 List 、Set、Sorted Set、 Hash\n\n**5.0的新类型**：\n\n- Bit arrays：位集合（可以实现类似布隆过滤器的功能结构）\n- HyperLogLog：是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。\n- Geospatial Indexes：地理空间索引\n- Streams：流信息\n\n**Redis哨兵模式**\n\nsentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。\n\n**RabbitMQ工作模式**\n\n简单队列模式、工作队列模式、发布订阅模式、路由模式、主题模式\n\n**创建线程方式**\n\nThread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）\n\n线程池使用\n\n**Map子类**\n\nHashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap\n\n**JDK1.8Stream方法**\n\nfilter+-> |sorted+-> |map+-> |collect|\n\n**MySQL数据类型**\n\n数值、日期/时间和字符串(字符)类型\n\nint、double、decimal、date、time、char、varchar、text、blob\n\n**事务特性**\n\nACID 原子性、一致性、隔离性、持久性\n\n- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n**Git和SVN区别**\n\nSVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。\n\n**Meven父子项目包**\n\n父工程保留pom.xml并在modles添加子工程 ，在子工程pom中依赖父工程并在build添加maven打包依赖\n","source":"_posts/2021-04-17面试嘉立创.md","raw":"---\ntitle: 2021/04/17面试嘉立创\ndate: 2021-04-18 13:47:01\ntags:\n---\n**Oracle 数据类型：**\n\n- 字符串类型 char nchar varchar nvarchar2\n- 数字类型 number integer\n- 日期类型 date TIMESTAMP\n- LOB类型 BLOB二进制 CLOB大文本\n\n**Redis 数据类型**：String、 List 、Set、Sorted Set、 Hash\n\n**5.0的新类型**：\n\n- Bit arrays：位集合（可以实现类似布隆过滤器的功能结构）\n- HyperLogLog：是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。\n- Geospatial Indexes：地理空间索引\n- Streams：流信息\n\n**Redis哨兵模式**\n\nsentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。\n\n**RabbitMQ工作模式**\n\n简单队列模式、工作队列模式、发布订阅模式、路由模式、主题模式\n\n**创建线程方式**\n\nThread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）\n\n线程池使用\n\n**Map子类**\n\nHashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap\n\n**JDK1.8Stream方法**\n\nfilter+-> |sorted+-> |map+-> |collect|\n\n**MySQL数据类型**\n\n数值、日期/时间和字符串(字符)类型\n\nint、double、decimal、date、time、char、varchar、text、blob\n\n**事务特性**\n\nACID 原子性、一致性、隔离性、持久性\n\n- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[[1\\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)\n- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n**Git和SVN区别**\n\nSVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。\n\n**Meven父子项目包**\n\n父工程保留pom.xml并在modles添加子工程 ，在子工程pom中依赖父工程并在build添加maven打包依赖\n","slug":"2021-04-17面试嘉立创","published":1,"updated":"2023-02-13T07:23:47.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjm0005joeja8m68861","content":"<p><strong>Oracle 数据类型：</strong></p>\n<ul>\n<li>字符串类型 char nchar varchar nvarchar2</li>\n<li>数字类型 number integer</li>\n<li>日期类型 date TIMESTAMP</li>\n<li>LOB类型 BLOB二进制 CLOB大文本</li>\n</ul>\n<p><strong>Redis 数据类型</strong>：String、 List 、Set、Sorted Set、 Hash</p>\n<p><strong>5.0的新类型</strong>：</p>\n<ul>\n<li>Bit arrays：位集合（可以实现类似布隆过滤器的功能结构）</li>\n<li>HyperLogLog：是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。</li>\n<li>Geospatial Indexes：地理空间索引</li>\n<li>Streams：流信息</li>\n</ul>\n<p><strong>Redis哨兵模式</strong></p>\n<p>sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。</p>\n<p><strong>RabbitMQ工作模式</strong></p>\n<p>简单队列模式、工作队列模式、发布订阅模式、路由模式、主题模式</p>\n<p><strong>创建线程方式</strong></p>\n<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>\n<p>线程池使用</p>\n<p><strong>Map子类</strong></p>\n<p>HashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap</p>\n<p><strong>JDK1.8Stream方法</strong></p>\n<p>filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</p>\n<p><strong>MySQL数据类型</strong></p>\n<p>数值、日期&#x2F;时间和字符串(字符)类型</p>\n<p>int、double、decimal、date、time、char、varchar、text、blob</p>\n<p><strong>事务特性</strong></p>\n<p>ACID 原子性、一致性、隔离性、持久性</p>\n<ul>\n<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)\">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7\">约束</a>、<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)\">触发器</a>、<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A\">级联回滚</a>等。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<p><strong>Git和SVN区别</strong></p>\n<p>SVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。</p>\n<p><strong>Meven父子项目包</strong></p>\n<p>父工程保留pom.xml并在modles添加子工程 ，在子工程pom中依赖父工程并在build添加maven打包依赖</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Oracle 数据类型：</strong></p>\n<ul>\n<li>字符串类型 char nchar varchar nvarchar2</li>\n<li>数字类型 number integer</li>\n<li>日期类型 date TIMESTAMP</li>\n<li>LOB类型 BLOB二进制 CLOB大文本</li>\n</ul>\n<p><strong>Redis 数据类型</strong>：String、 List 、Set、Sorted Set、 Hash</p>\n<p><strong>5.0的新类型</strong>：</p>\n<ul>\n<li>Bit arrays：位集合（可以实现类似布隆过滤器的功能结构）</li>\n<li>HyperLogLog：是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。</li>\n<li>Geospatial Indexes：地理空间索引</li>\n<li>Streams：流信息</li>\n</ul>\n<p><strong>Redis哨兵模式</strong></p>\n<p>sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。</p>\n<p><strong>RabbitMQ工作模式</strong></p>\n<p>简单队列模式、工作队列模式、发布订阅模式、路由模式、主题模式</p>\n<p><strong>创建线程方式</strong></p>\n<p>Thread重写run方法 Runnable重写run方法 Callable重写call结合Futrue（阻塞）</p>\n<p>线程池使用</p>\n<p><strong>Map子类</strong></p>\n<p>HashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap</p>\n<p><strong>JDK1.8Stream方法</strong></p>\n<p>filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</p>\n<p><strong>MySQL数据类型</strong></p>\n<p>数值、日期&#x2F;时间和字符串(字符)类型</p>\n<p>int、double、decimal、date、time、char、varchar、text、blob</p>\n<p><strong>事务特性</strong></p>\n<p>ACID 原子性、一致性、隔离性、持久性</p>\n<ul>\n<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)\">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7\">约束</a>、<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)\">触发器</a>、<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A\">级联回滚</a>等。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[<a href=\"https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1\">1]</a></li>\n<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<p><strong>Git和SVN区别</strong></p>\n<p>SVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。</p>\n<p><strong>Meven父子项目包</strong></p>\n<p>父工程保留pom.xml并在modles添加子工程 ，在子工程pom中依赖父工程并在build添加maven打包依赖</p>\n"},{"title":"Redis分布式锁","date":"2021-04-15T11:43:52.000Z","_content":"(1) 锁的可靠性具备的四个方面\n\n互斥性：在任意时刻，只有一个客户端能持有锁。\n不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。\n具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。\n解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。\n(2) 加锁\n\n可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：\n\n第一个为key，我们使用key来当锁，因为key是唯一的。\n第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。\n第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n第四个为expx，这个参数我们传的是EX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n第五个为time，与第四个参数相呼应，代表key的过期时间。\n总的来说，执行上面的set()方法就只会导致两种结果：\n\n当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。\n已有锁存在，不做任何操作。\n我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。\n","source":"_posts/Redis分布式锁.md","raw":"---\ntitle: Redis分布式锁\ndate: 2021-04-15 19:43:52\ntags:\n---\n(1) 锁的可靠性具备的四个方面\n\n互斥性：在任意时刻，只有一个客户端能持有锁。\n不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。\n具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。\n解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。\n(2) 加锁\n\n可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：\n\n第一个为key，我们使用key来当锁，因为key是唯一的。\n第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。\n第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n第四个为expx，这个参数我们传的是EX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n第五个为time，与第四个参数相呼应，代表key的过期时间。\n总的来说，执行上面的set()方法就只会导致两种结果：\n\n当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。\n已有锁存在，不做任何操作。\n我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。\n","slug":"Redis分布式锁","published":1,"updated":"2023-02-13T07:23:23.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjn0006joejddib1vcy","content":"<p>(1) 锁的可靠性具备的四个方面</p>\n<p>互斥性：在任意时刻，只有一个客户端能持有锁。<br>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br>具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。<br>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。<br>(2) 加锁</p>\n<p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p>\n<p>第一个为key，我们使用key来当锁，因为key是唯一的。<br>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。<br>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；<br>第四个为expx，这个参数我们传的是EX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。<br>第五个为time，与第四个参数相呼应，代表key的过期时间。<br>总的来说，执行上面的set()方法就只会导致两种结果：</p>\n<p>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。<br>已有锁存在，不做任何操作。<br>我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>(1) 锁的可靠性具备的四个方面</p>\n<p>互斥性：在任意时刻，只有一个客户端能持有锁。<br>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br>具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。<br>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。<br>(2) 加锁</p>\n<p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p>\n<p>第一个为key，我们使用key来当锁，因为key是唯一的。<br>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。<br>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；<br>第四个为expx，这个参数我们传的是EX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。<br>第五个为time，与第四个参数相呼应，代表key的过期时间。<br>总的来说，执行上面的set()方法就只会导致两种结果：</p>\n<p>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。<br>已有锁存在，不做任何操作。<br>我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>\n"},{"title":"SpringCloud开启DashBoard监控","date":"2021-04-11T07:49:02.000Z","_content":"1. 导入DashBoard依赖\n2. 在需要监控的服务中导入actuator依赖，注入一个Bean将 `registrationBean.addUrlMappings(\"/actuator/hystrix.stream\");`\n3. 在需要监控的接口加上@HystrixCommand注解\n4. 启动类添加@EnableCircuitBreaker注解\n5. 监控服务参数修改 hystrix.dashboard.proxy-stream-allow-list: \"*\"\n","source":"_posts/SpringCloud开启DashBoard监控.md","raw":"---\ntitle: SpringCloud开启DashBoard监控\ndate: 2021-04-11 15:49:02\ntags:\n---\n1. 导入DashBoard依赖\n2. 在需要监控的服务中导入actuator依赖，注入一个Bean将 `registrationBean.addUrlMappings(\"/actuator/hystrix.stream\");`\n3. 在需要监控的接口加上@HystrixCommand注解\n4. 启动类添加@EnableCircuitBreaker注解\n5. 监控服务参数修改 hystrix.dashboard.proxy-stream-allow-list: \"*\"\n","slug":"SpringCloud开启DashBoard监控","published":1,"updated":"2023-02-13T07:22:34.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjo0007joejf2wghram","content":"<ol>\n<li>导入DashBoard依赖</li>\n<li>在需要监控的服务中导入actuator依赖，注入一个Bean将 <code>registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);</code></li>\n<li>在需要监控的接口加上@HystrixCommand注解</li>\n<li>启动类添加@EnableCircuitBreaker注解</li>\n<li>监控服务参数修改 hystrix.dashboard.proxy-stream-allow-list: “*”</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>导入DashBoard依赖</li>\n<li>在需要监控的服务中导入actuator依赖，注入一个Bean将 <code>registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);</code></li>\n<li>在需要监控的接口加上@HystrixCommand注解</li>\n<li>启动类添加@EnableCircuitBreaker注解</li>\n<li>监控服务参数修改 hystrix.dashboard.proxy-stream-allow-list: “*”</li>\n</ol>\n"},{"title":"Spring事务","date":"2021-04-11T16:45:59.000Z","_content":"#### **ACID属性**\n\n提到事务，不可避免需要涉及到事务的ACID属性：\n\n- **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n- **一致性：** 执行事务前后，数据保持一致；\n- **隔离性：** 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；\n- **持久性:**  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n#### 事务隔离级别\n\n- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复度和幻读区别：**\n\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n\n#####  TransactionDefinition 接口中定义了五个表示隔离级别的常量：\n\n- **TransactionDefinition.ISOLATION_DEFAULT:**\t使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.\n- **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**\n- **TransactionDefinition.ISOLATION_READ_COMMITTED:** \t允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**\n- **TransactionDefinition.ISOLATION_REPEATABLE_READ:** \t对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**\n- **TransactionDefinition.ISOLATION_SERIALIZABLE:** \t最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n#### 事务传播行为\n\n**支持当前事务的情况：**\n\n- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。**子事务回滚，父事务一定回滚,父事务回滚，子事务一定回滚**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114091759506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center)\n\n- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n**不支持当前事务的情况：**\n\n- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114091904968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center)\n\n- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。\n\n**其他情况：**\n\n- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\n\n#### 为什么会有传播机制\n\nspring 对事务的控制，是使用 aop 切面实现的，我们不用关心事务的开始，提交 ，回滚，只需要在public方法上加 `@Transactional` 注解，这时候就有问题了。\n\n- 场景一： serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚。\n- 场景二：serviceA 方法调用了 serviceB 方法，但是只有 serviceA 方法加了事务，是否把 serviceB 也加入 serviceA 的事务，如果 serviceB 异常，是否回滚 serviceA 。\n- 场景三：serviceA 方法调用了 serviceB 方法，两者都有事务，serviceB 已经正常执行完，但 serviceA 异常，是否需要回滚 serviceB 的数据。 回滚\n\n### 传播机制生效条件\n\nspring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的\n\n#### @Transactional失效场景\n\n1. @Transactional 应用在非 public 修饰的方法上\n2. @Transactional 注解属性 propagation 设置错误\n3. @Transactional 注解属性 rollbackFor 设置错误\n4. 同一个类中方法调用，导致@Transactional失效\n5. 异常被你的 catch“吃了”导致@Transactional失效\n6. 数据库引擎不支持事务\n","source":"_posts/Spring事务.md","raw":"---\ntitle: Spring事务\ndate: 2021-04-12 00:45:59\ntags:\n---\n#### **ACID属性**\n\n提到事务，不可避免需要涉及到事务的ACID属性：\n\n- **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n- **一致性：** 执行事务前后，数据保持一致；\n- **隔离性：** 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；\n- **持久性:**  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n#### 事务隔离级别\n\n- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复度和幻读区别：**\n\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n\n#####  TransactionDefinition 接口中定义了五个表示隔离级别的常量：\n\n- **TransactionDefinition.ISOLATION_DEFAULT:**\t使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.\n- **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**\n- **TransactionDefinition.ISOLATION_READ_COMMITTED:** \t允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**\n- **TransactionDefinition.ISOLATION_REPEATABLE_READ:** \t对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**\n- **TransactionDefinition.ISOLATION_SERIALIZABLE:** \t最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n#### 事务传播行为\n\n**支持当前事务的情况：**\n\n- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。**子事务回滚，父事务一定回滚,父事务回滚，子事务一定回滚**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114091759506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center)\n\n- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n**不支持当前事务的情况：**\n\n- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114091904968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center)\n\n- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。\n\n**其他情况：**\n\n- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\n\n#### 为什么会有传播机制\n\nspring 对事务的控制，是使用 aop 切面实现的，我们不用关心事务的开始，提交 ，回滚，只需要在public方法上加 `@Transactional` 注解，这时候就有问题了。\n\n- 场景一： serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚。\n- 场景二：serviceA 方法调用了 serviceB 方法，但是只有 serviceA 方法加了事务，是否把 serviceB 也加入 serviceA 的事务，如果 serviceB 异常，是否回滚 serviceA 。\n- 场景三：serviceA 方法调用了 serviceB 方法，两者都有事务，serviceB 已经正常执行完，但 serviceA 异常，是否需要回滚 serviceB 的数据。 回滚\n\n### 传播机制生效条件\n\nspring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的\n\n#### @Transactional失效场景\n\n1. @Transactional 应用在非 public 修饰的方法上\n2. @Transactional 注解属性 propagation 设置错误\n3. @Transactional 注解属性 rollbackFor 设置错误\n4. 同一个类中方法调用，导致@Transactional失效\n5. 异常被你的 catch“吃了”导致@Transactional失效\n6. 数据库引擎不支持事务\n","slug":"Spring事务","published":1,"updated":"2023-02-13T07:22:54.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjo0008joejfhisgvln","content":"<h4 id=\"ACID属性\"><a href=\"#ACID属性\" class=\"headerlink\" title=\"ACID属性\"></a><strong>ACID属性</strong></h4><p>提到事务，不可避免需要涉及到事务的ACID属性：</p>\n<ul>\n<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li>\n<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><ul>\n<li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>\n</li>\n<li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p>\n</li>\n<li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n</li>\n<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n</li>\n</ul>\n<p><strong>不可重复度和幻读区别：</strong></p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<h5 id=\"TransactionDefinition-接口中定义了五个表示隔离级别的常量：\"><a href=\"#TransactionDefinition-接口中定义了五个表示隔离级别的常量：\" class=\"headerlink\" title=\"TransactionDefinition 接口中定义了五个表示隔离级别的常量：\"></a>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</h5><ul>\n<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>\t使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>\n<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> \t允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> \t对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> \t最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>\n</ul>\n<h4 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h4><p><strong>支持当前事务的情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>子事务回滚，父事务一定回滚,父事务回滚，子事务一定回滚</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210114091759506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>\n</ul>\n<p><strong>不支持当前事务的情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210114091904968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ul>\n<p><strong>其他情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>\n</ul>\n<h4 id=\"为什么会有传播机制\"><a href=\"#为什么会有传播机制\" class=\"headerlink\" title=\"为什么会有传播机制\"></a>为什么会有传播机制</h4><p>spring 对事务的控制，是使用 aop 切面实现的，我们不用关心事务的开始，提交 ，回滚，只需要在public方法上加 <code>@Transactional</code> 注解，这时候就有问题了。</p>\n<ul>\n<li>场景一： serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚。</li>\n<li>场景二：serviceA 方法调用了 serviceB 方法，但是只有 serviceA 方法加了事务，是否把 serviceB 也加入 serviceA 的事务，如果 serviceB 异常，是否回滚 serviceA 。</li>\n<li>场景三：serviceA 方法调用了 serviceB 方法，两者都有事务，serviceB 已经正常执行完，但 serviceA 异常，是否需要回滚 serviceB 的数据。 回滚</li>\n</ul>\n<h3 id=\"传播机制生效条件\"><a href=\"#传播机制生效条件\" class=\"headerlink\" title=\"传播机制生效条件\"></a>传播机制生效条件</h3><p>spring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的</p>\n<h4 id=\"Transactional失效场景\"><a href=\"#Transactional失效场景\" class=\"headerlink\" title=\"@Transactional失效场景\"></a>@Transactional失效场景</h4><ol>\n<li>@Transactional 应用在非 public 修饰的方法上</li>\n<li>@Transactional 注解属性 propagation 设置错误</li>\n<li>@Transactional 注解属性 rollbackFor 设置错误</li>\n<li>同一个类中方法调用，导致@Transactional失效</li>\n<li>异常被你的 catch“吃了”导致@Transactional失效</li>\n<li>数据库引擎不支持事务</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"ACID属性\"><a href=\"#ACID属性\" class=\"headerlink\" title=\"ACID属性\"></a><strong>ACID属性</strong></h4><p>提到事务，不可避免需要涉及到事务的ACID属性：</p>\n<ul>\n<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li>\n<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><ul>\n<li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>\n</li>\n<li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p>\n</li>\n<li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n</li>\n<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n</li>\n</ul>\n<p><strong>不可重复度和幻读区别：</strong></p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<h5 id=\"TransactionDefinition-接口中定义了五个表示隔离级别的常量：\"><a href=\"#TransactionDefinition-接口中定义了五个表示隔离级别的常量：\" class=\"headerlink\" title=\"TransactionDefinition 接口中定义了五个表示隔离级别的常量：\"></a>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</h5><ul>\n<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>\t使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>\n<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> \t允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> \t对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>\n<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> \t最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>\n</ul>\n<h4 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h4><p><strong>支持当前事务的情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>子事务回滚，父事务一定回滚,父事务回滚，子事务一定回滚</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210114091759506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>\n</ul>\n<p><strong>不支持当前事务的情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210114091904968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYzMTMw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ul>\n<p><strong>其他情况：</strong></p>\n<ul>\n<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>\n</ul>\n<h4 id=\"为什么会有传播机制\"><a href=\"#为什么会有传播机制\" class=\"headerlink\" title=\"为什么会有传播机制\"></a>为什么会有传播机制</h4><p>spring 对事务的控制，是使用 aop 切面实现的，我们不用关心事务的开始，提交 ，回滚，只需要在public方法上加 <code>@Transactional</code> 注解，这时候就有问题了。</p>\n<ul>\n<li>场景一： serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚。</li>\n<li>场景二：serviceA 方法调用了 serviceB 方法，但是只有 serviceA 方法加了事务，是否把 serviceB 也加入 serviceA 的事务，如果 serviceB 异常，是否回滚 serviceA 。</li>\n<li>场景三：serviceA 方法调用了 serviceB 方法，两者都有事务，serviceB 已经正常执行完，但 serviceA 异常，是否需要回滚 serviceB 的数据。 回滚</li>\n</ul>\n<h3 id=\"传播机制生效条件\"><a href=\"#传播机制生效条件\" class=\"headerlink\" title=\"传播机制生效条件\"></a>传播机制生效条件</h3><p>spring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的</p>\n<h4 id=\"Transactional失效场景\"><a href=\"#Transactional失效场景\" class=\"headerlink\" title=\"@Transactional失效场景\"></a>@Transactional失效场景</h4><ol>\n<li>@Transactional 应用在非 public 修饰的方法上</li>\n<li>@Transactional 注解属性 propagation 设置错误</li>\n<li>@Transactional 注解属性 rollbackFor 设置错误</li>\n<li>同一个类中方法调用，导致@Transactional失效</li>\n<li>异常被你的 catch“吃了”导致@Transactional失效</li>\n<li>数据库引擎不支持事务</li>\n</ol>\n"},{"title":"Spring代理那些事","date":"2021-04-13T15:25:56.000Z","_content":"### JDK动态代理\n\nSpringBoot2.0之前对接口默认试用JDK动态代理\nJDK动态代理会生成一个继承自Proxy类的子类并实现原有接口\n\n### CGLIB代理\nCGLIB代理通过生成一个代理对象的子类来实现代理\n","source":"_posts/Spring代理那些事.md","raw":"---\ntitle: Spring代理那些事\ndate: 2021-04-13 23:25:56\ntags:\n---\n### JDK动态代理\n\nSpringBoot2.0之前对接口默认试用JDK动态代理\nJDK动态代理会生成一个继承自Proxy类的子类并实现原有接口\n\n### CGLIB代理\nCGLIB代理通过生成一个代理对象的子类来实现代理\n","slug":"Spring代理那些事","published":1,"updated":"2023-02-13T07:23:06.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjp0009joej820t6tin","content":"<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>SpringBoot2.0之前对接口默认试用JDK动态代理<br>JDK动态代理会生成一个继承自Proxy类的子类并实现原有接口</p>\n<h3 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h3><p>CGLIB代理通过生成一个代理对象的子类来实现代理</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>SpringBoot2.0之前对接口默认试用JDK动态代理<br>JDK动态代理会生成一个继承自Proxy类的子类并实现原有接口</p>\n<h3 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h3><p>CGLIB代理通过生成一个代理对象的子类来实现代理</p>\n"},{"title":"docker-compose 常用命令","date":"2021-04-07T13:10:58.000Z","_content":"## docker-compose 常用命令\n\n1. docker-compose build\t(构建yml中某个服务的镜像)\n1. docker-compose ps\t(查看已经启动的服务状态）\n1. docker-compose kill\t(停止某个服务）\n1. docker-compose logs\t(可以查看某个服务的log）\n1. docker-compose port\t(打印绑定的public port）\n1. docker-compose pull\t(pull服务镜像)\n1. docker-compose up\t(启动yml定义的所有服务）\n1. docker-compose stop\t(停止yml中定义的所有服务）\n1. docker-compose start\t(启动被停止的yml中的所有服务）\n1. docker-compose kill\t(强行停止yml中定义的所有服务）\n1. docker-compose rm\t（删除yml中定义的所有服务）\n1. docker-compose restart\t(重启yml中定义的所有服务）\n1. docker-compose scale\t(扩展某个服务的个数，可以向上或向下）\n1. docker-compose version\t（查看compose的版本）\n","source":"_posts/docker-compose-常用命令.md","raw":"---\ntitle: docker-compose 常用命令\ndate: 2021-04-07 21:10:58\ntags:\n---\n## docker-compose 常用命令\n\n1. docker-compose build\t(构建yml中某个服务的镜像)\n1. docker-compose ps\t(查看已经启动的服务状态）\n1. docker-compose kill\t(停止某个服务）\n1. docker-compose logs\t(可以查看某个服务的log）\n1. docker-compose port\t(打印绑定的public port）\n1. docker-compose pull\t(pull服务镜像)\n1. docker-compose up\t(启动yml定义的所有服务）\n1. docker-compose stop\t(停止yml中定义的所有服务）\n1. docker-compose start\t(启动被停止的yml中的所有服务）\n1. docker-compose kill\t(强行停止yml中定义的所有服务）\n1. docker-compose rm\t（删除yml中定义的所有服务）\n1. docker-compose restart\t(重启yml中定义的所有服务）\n1. docker-compose scale\t(扩展某个服务的个数，可以向上或向下）\n1. docker-compose version\t（查看compose的版本）\n","slug":"docker-compose-常用命令","published":1,"updated":"2023-02-13T07:22:01.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjq000ajoejas3wfkfh","content":"<h2 id=\"docker-compose-常用命令\"><a href=\"#docker-compose-常用命令\" class=\"headerlink\" title=\"docker-compose 常用命令\"></a>docker-compose 常用命令</h2><ol>\n<li>docker-compose build\t(构建yml中某个服务的镜像)</li>\n<li>docker-compose ps\t(查看已经启动的服务状态）</li>\n<li>docker-compose kill\t(停止某个服务）</li>\n<li>docker-compose logs\t(可以查看某个服务的log）</li>\n<li>docker-compose port\t(打印绑定的public port）</li>\n<li>docker-compose pull\t(pull服务镜像)</li>\n<li>docker-compose up\t(启动yml定义的所有服务）</li>\n<li>docker-compose stop\t(停止yml中定义的所有服务）</li>\n<li>docker-compose start\t(启动被停止的yml中的所有服务）</li>\n<li>docker-compose kill\t(强行停止yml中定义的所有服务）</li>\n<li>docker-compose rm\t（删除yml中定义的所有服务）</li>\n<li>docker-compose restart\t(重启yml中定义的所有服务）</li>\n<li>docker-compose scale\t(扩展某个服务的个数，可以向上或向下）</li>\n<li>docker-compose version\t（查看compose的版本）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"docker-compose-常用命令\"><a href=\"#docker-compose-常用命令\" class=\"headerlink\" title=\"docker-compose 常用命令\"></a>docker-compose 常用命令</h2><ol>\n<li>docker-compose build\t(构建yml中某个服务的镜像)</li>\n<li>docker-compose ps\t(查看已经启动的服务状态）</li>\n<li>docker-compose kill\t(停止某个服务）</li>\n<li>docker-compose logs\t(可以查看某个服务的log）</li>\n<li>docker-compose port\t(打印绑定的public port）</li>\n<li>docker-compose pull\t(pull服务镜像)</li>\n<li>docker-compose up\t(启动yml定义的所有服务）</li>\n<li>docker-compose stop\t(停止yml中定义的所有服务）</li>\n<li>docker-compose start\t(启动被停止的yml中的所有服务）</li>\n<li>docker-compose kill\t(强行停止yml中定义的所有服务）</li>\n<li>docker-compose rm\t（删除yml中定义的所有服务）</li>\n<li>docker-compose restart\t(重启yml中定义的所有服务）</li>\n<li>docker-compose scale\t(扩展某个服务的个数，可以向上或向下）</li>\n<li>docker-compose version\t（查看compose的版本）</li>\n</ol>\n"},{"title":"服务熔断&降级","date":"2021-04-11T06:55:17.000Z","_content":"### 服务熔断\n\n所谓熔断就是建立类似电器里面的保险丝的功能，当客户端访问服务端的时候，发现服务端的请求出现异常，就直接断开，不再调用服务端，返回一个默认的数据\n\n还有半熔断的概念，就是客户端可以允许一部分的请求访问服务端，用来检测服务端是否正常，如果正常的话，那么就关闭熔断\n\n### 服务降级\n\n1、客户端降级：如果客户端发现服务端的服务不可用，那么**不再请求服务端，直接返回一个固定的数据给调用方**，对服务端的服务进行降级处理\n\n2、服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如**直接返回错误或者固定数据**\n","source":"_posts/服务熔断-降级.md","raw":"---\ntitle: 服务熔断&降级\ndate: 2021-04-11 14:55:17\ntags:\n---\n### 服务熔断\n\n所谓熔断就是建立类似电器里面的保险丝的功能，当客户端访问服务端的时候，发现服务端的请求出现异常，就直接断开，不再调用服务端，返回一个默认的数据\n\n还有半熔断的概念，就是客户端可以允许一部分的请求访问服务端，用来检测服务端是否正常，如果正常的话，那么就关闭熔断\n\n### 服务降级\n\n1、客户端降级：如果客户端发现服务端的服务不可用，那么**不再请求服务端，直接返回一个固定的数据给调用方**，对服务端的服务进行降级处理\n\n2、服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如**直接返回错误或者固定数据**\n","slug":"服务熔断-降级","published":1,"updated":"2023-02-13T07:22:26.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjq000bjoej0ves0qhc","content":"<h3 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h3><p>所谓熔断就是建立类似电器里面的保险丝的功能，当客户端访问服务端的时候，发现服务端的请求出现异常，就直接断开，不再调用服务端，返回一个默认的数据</p>\n<p>还有半熔断的概念，就是客户端可以允许一部分的请求访问服务端，用来检测服务端是否正常，如果正常的话，那么就关闭熔断</p>\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><p>1、客户端降级：如果客户端发现服务端的服务不可用，那么<strong>不再请求服务端，直接返回一个固定的数据给调用方</strong>，对服务端的服务进行降级处理</p>\n<p>2、服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如<strong>直接返回错误或者固定数据</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h3><p>所谓熔断就是建立类似电器里面的保险丝的功能，当客户端访问服务端的时候，发现服务端的请求出现异常，就直接断开，不再调用服务端，返回一个默认的数据</p>\n<p>还有半熔断的概念，就是客户端可以允许一部分的请求访问服务端，用来检测服务端是否正常，如果正常的话，那么就关闭熔断</p>\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><p>1、客户端降级：如果客户端发现服务端的服务不可用，那么<strong>不再请求服务端，直接返回一个固定的数据给调用方</strong>，对服务端的服务进行降级处理</p>\n<p>2、服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如<strong>直接返回错误或者固定数据</strong></p>\n"},{"title":"将 MySQL 服务加入防火墙","date":"2020-07-19T05:11:17.000Z","_content":"## [root@centos-linux ~]# sudo firewall-cmd --zone=public --permanent --add-service=mysql\n## success\n## [root@centos-linux ~]# sudo systemctl restart firewalld\n","source":"_posts/将 MySQL 服务加入防火墙.md","raw":"---\ntitle: 将 MySQL 服务加入防火墙\ndate: 2020-07-19 13:11:17\ntags:\n---\n## [root@centos-linux ~]# sudo firewall-cmd --zone=public --permanent --add-service=mysql\n## success\n## [root@centos-linux ~]# sudo systemctl restart firewalld\n","slug":"将 MySQL 服务加入防火墙","published":1,"updated":"2023-02-13T07:15:37.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjr000cjoejfmhzczm5","content":"<h2 id=\"root-centos-linux-sudo-firewall-cmd-–zone-x3D-public-–permanent-–add-service-x3D-mysql\"><a href=\"#root-centos-linux-sudo-firewall-cmd-–zone-x3D-public-–permanent-–add-service-x3D-mysql\" class=\"headerlink\" title=\"[root@centos-linux ~]# sudo firewall-cmd –zone&#x3D;public –permanent –add-service&#x3D;mysql\"></a>[root@centos-linux ~]# sudo firewall-cmd –zone&#x3D;public –permanent –add-service&#x3D;mysql</h2><h2 id=\"success\"><a href=\"#success\" class=\"headerlink\" title=\"success\"></a>success</h2><h2 id=\"root-centos-linux-sudo-systemctl-restart-firewalld\"><a href=\"#root-centos-linux-sudo-systemctl-restart-firewalld\" class=\"headerlink\" title=\"[root@centos-linux ~]# sudo systemctl restart firewalld\"></a>[root@centos-linux ~]# sudo systemctl restart firewalld</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"root-centos-linux-sudo-firewall-cmd-–zone-x3D-public-–permanent-–add-service-x3D-mysql\"><a href=\"#root-centos-linux-sudo-firewall-cmd-–zone-x3D-public-–permanent-–add-service-x3D-mysql\" class=\"headerlink\" title=\"[root@centos-linux ~]# sudo firewall-cmd –zone&#x3D;public –permanent –add-service&#x3D;mysql\"></a>[root@centos-linux ~]# sudo firewall-cmd –zone&#x3D;public –permanent –add-service&#x3D;mysql</h2><h2 id=\"success\"><a href=\"#success\" class=\"headerlink\" title=\"success\"></a>success</h2><h2 id=\"root-centos-linux-sudo-systemctl-restart-firewalld\"><a href=\"#root-centos-linux-sudo-systemctl-restart-firewalld\" class=\"headerlink\" title=\"[root@centos-linux ~]# sudo systemctl restart firewalld\"></a>[root@centos-linux ~]# sudo systemctl restart firewalld</h2>"},{"title":"杀死指定端口号进程","date":"2021-01-12T07:15:44.000Z","_content":"```\n\n#杀死特定端口号的进程\n#方法一:\n    kill -9 `lsof -i:18100 | awk 'NR==2{print $2}'`\n#方法二:\t\n    kill -9 `lsof -i | grep 18100 | awk '{print $2}'`\n#方法三:\n    kill -9 `ss -antlup | grep 18100 | awk '{print $7}' | awk -F'[=,]' '{print $3}'`\n```\n","source":"_posts/杀死指定端口号进程.md","raw":"---\ntitle: 杀死指定端口号进程\ndate: 2021-01-12 15:15:44\ntags:\n---\n```\n\n#杀死特定端口号的进程\n#方法一:\n    kill -9 `lsof -i:18100 | awk 'NR==2{print $2}'`\n#方法二:\t\n    kill -9 `lsof -i | grep 18100 | awk '{print $2}'`\n#方法三:\n    kill -9 `ss -antlup | grep 18100 | awk '{print $7}' | awk -F'[=,]' '{print $3}'`\n```\n","slug":"杀死指定端口号进程","published":1,"updated":"2023-02-13T07:21:29.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjr000djoejcqg25ej0","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#杀死特定端口号的进程</span><br><span class=\"line\">#方法一:</span><br><span class=\"line\">    kill -9 `lsof -i:18100 | awk &#x27;NR==2&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">#方法二:\t</span><br><span class=\"line\">    kill -9 `lsof -i | grep 18100 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">#方法三:</span><br><span class=\"line\">    kill -9 `ss -antlup | grep 18100 | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&#x27;[=,]&#x27; &#x27;&#123;print $3&#125;&#x27;`</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#杀死特定端口号的进程</span><br><span class=\"line\">#方法一:</span><br><span class=\"line\">    kill -9 `lsof -i:18100 | awk &#x27;NR==2&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">#方法二:\t</span><br><span class=\"line\">    kill -9 `lsof -i | grep 18100 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">#方法三:</span><br><span class=\"line\">    kill -9 `ss -antlup | grep 18100 | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&#x27;[=,]&#x27; &#x27;&#123;print $3&#125;&#x27;`</span><br></pre></td></tr></table></figure>\n"},{"title":"模拟面试","date":"2021-04-11T14:30:58.000Z","_content":"### 模拟面试\n\n\n\n#### HashMap\n\n- resize（） tanster（） 数组+链表/红黑树 并发使用CurrentHashMap 分段锁 HashTable整锁\n- 为什么是2倍？ 方便位运算 rehash\n\n#### CurrentHashMap\n\n- 结构与HashMap基本一致，Node包括 key value next 指向下一Node\n- 负载因子不可修改\n- Node.hash字段一般>=0  :\n- 线程安全 sychronized 锁通的头节点  若为空则CAS\n- 寻址算法：key的hashcode 扰动运算  高16低16\n\n#### Spring\n\n-  事务隔离级别、传播特性\n\n-  AOP 动态代理是Spring实现AOP的默认方式，分为两种：**JDK动态代理**和**CGLIB动态代理**。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者`objenesis`类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。\n\n\n\n#### 设计模式\n\n- 观察者模式：一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象；rabbitmq中的fanout模式\n- 代理模式：给一个对象提供一个对象，通过代理对象控制源对象的引用。生活中例子 中介；\n\n\n\n#### 索引\n\n- 主键、唯一、联合、全文、普通，聚簇索引 叶子节点 行数据  回表查询\n\n\n\n#### 微服务\n\n- Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。注解为**@LoadBalanced**  与Nginx区别：Nginx服务端，Ribbon客户端\n\n- Hystrix预防雪崩：友好提示，\n\n    - 服务降级：接口调用失败就调用本地的方法返回一个空\n\n    - 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息\n\n    - 服务隔离：隔离服务之间相互影响\n\n    - 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。\n\n- 服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。\n\n- 服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。\n\n- 服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。\n\n- Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 **调用方法要和本地抽象方法的签名完全一致**\n","source":"_posts/模拟面试.md","raw":"---\ntitle: 模拟面试\ndate: 2021-04-11 22:30:58\ntags:\n---\n### 模拟面试\n\n\n\n#### HashMap\n\n- resize（） tanster（） 数组+链表/红黑树 并发使用CurrentHashMap 分段锁 HashTable整锁\n- 为什么是2倍？ 方便位运算 rehash\n\n#### CurrentHashMap\n\n- 结构与HashMap基本一致，Node包括 key value next 指向下一Node\n- 负载因子不可修改\n- Node.hash字段一般>=0  :\n- 线程安全 sychronized 锁通的头节点  若为空则CAS\n- 寻址算法：key的hashcode 扰动运算  高16低16\n\n#### Spring\n\n-  事务隔离级别、传播特性\n\n-  AOP 动态代理是Spring实现AOP的默认方式，分为两种：**JDK动态代理**和**CGLIB动态代理**。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者`objenesis`类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。\n\n\n\n#### 设计模式\n\n- 观察者模式：一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象；rabbitmq中的fanout模式\n- 代理模式：给一个对象提供一个对象，通过代理对象控制源对象的引用。生活中例子 中介；\n\n\n\n#### 索引\n\n- 主键、唯一、联合、全文、普通，聚簇索引 叶子节点 行数据  回表查询\n\n\n\n#### 微服务\n\n- Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。注解为**@LoadBalanced**  与Nginx区别：Nginx服务端，Ribbon客户端\n\n- Hystrix预防雪崩：友好提示，\n\n    - 服务降级：接口调用失败就调用本地的方法返回一个空\n\n    - 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息\n\n    - 服务隔离：隔离服务之间相互影响\n\n    - 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。\n\n- 服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。\n\n- 服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。\n\n- 服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。\n\n- Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 **调用方法要和本地抽象方法的签名完全一致**\n","slug":"模拟面试","published":1,"updated":"2023-02-13T07:22:44.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle2hptjs000ejoeja8qz9d3w","content":"<h3 id=\"模拟面试\"><a href=\"#模拟面试\" class=\"headerlink\" title=\"模拟面试\"></a>模拟面试</h3><h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><ul>\n<li>resize（） tanster（） 数组+链表&#x2F;红黑树 并发使用CurrentHashMap 分段锁 HashTable整锁</li>\n<li>为什么是2倍？ 方便位运算 rehash</li>\n</ul>\n<h4 id=\"CurrentHashMap\"><a href=\"#CurrentHashMap\" class=\"headerlink\" title=\"CurrentHashMap\"></a>CurrentHashMap</h4><ul>\n<li>结构与HashMap基本一致，Node包括 key value next 指向下一Node</li>\n<li>负载因子不可修改</li>\n<li>Node.hash字段一般&gt;&#x3D;0  :</li>\n<li>线程安全 sychronized 锁通的头节点  若为空则CAS</li>\n<li>寻址算法：key的hashcode 扰动运算  高16低16</li>\n</ul>\n<h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4><ul>\n<li><p>事务隔离级别、传播特性</p>\n</li>\n<li><p>AOP 动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p>\n</li>\n</ul>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><ul>\n<li>观察者模式：一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象；rabbitmq中的fanout模式</li>\n<li>代理模式：给一个对象提供一个对象，通过代理对象控制源对象的引用。生活中例子 中介；</li>\n</ul>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ul>\n<li>主键、唯一、联合、全文、普通，聚簇索引 叶子节点 行数据  回表查询</li>\n</ul>\n<h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4><ul>\n<li><p>Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。注解为**@LoadBalanced**  与Nginx区别：Nginx服务端，Ribbon客户端</p>\n</li>\n<li><p>Hystrix预防雪崩：友好提示，</p>\n<ul>\n<li><p>服务降级：接口调用失败就调用本地的方法返回一个空</p>\n</li>\n<li><p>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</p>\n</li>\n<li><p>服务隔离：隔离服务之间相互影响</p>\n</li>\n<li><p>服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</p>\n</li>\n</ul>\n</li>\n<li><p>服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</p>\n</li>\n<li><p>服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。</p>\n</li>\n<li><p>服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。</p>\n</li>\n<li><p>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 <strong>调用方法要和本地抽象方法的签名完全一致</strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模拟面试\"><a href=\"#模拟面试\" class=\"headerlink\" title=\"模拟面试\"></a>模拟面试</h3><h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><ul>\n<li>resize（） tanster（） 数组+链表&#x2F;红黑树 并发使用CurrentHashMap 分段锁 HashTable整锁</li>\n<li>为什么是2倍？ 方便位运算 rehash</li>\n</ul>\n<h4 id=\"CurrentHashMap\"><a href=\"#CurrentHashMap\" class=\"headerlink\" title=\"CurrentHashMap\"></a>CurrentHashMap</h4><ul>\n<li>结构与HashMap基本一致，Node包括 key value next 指向下一Node</li>\n<li>负载因子不可修改</li>\n<li>Node.hash字段一般&gt;&#x3D;0  :</li>\n<li>线程安全 sychronized 锁通的头节点  若为空则CAS</li>\n<li>寻址算法：key的hashcode 扰动运算  高16低16</li>\n</ul>\n<h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4><ul>\n<li><p>事务隔离级别、传播特性</p>\n</li>\n<li><p>AOP 动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p>\n</li>\n</ul>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><ul>\n<li>观察者模式：一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象；rabbitmq中的fanout模式</li>\n<li>代理模式：给一个对象提供一个对象，通过代理对象控制源对象的引用。生活中例子 中介；</li>\n</ul>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ul>\n<li>主键、唯一、联合、全文、普通，聚簇索引 叶子节点 行数据  回表查询</li>\n</ul>\n<h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4><ul>\n<li><p>Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。注解为**@LoadBalanced**  与Nginx区别：Nginx服务端，Ribbon客户端</p>\n</li>\n<li><p>Hystrix预防雪崩：友好提示，</p>\n<ul>\n<li><p>服务降级：接口调用失败就调用本地的方法返回一个空</p>\n</li>\n<li><p>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</p>\n</li>\n<li><p>服务隔离：隔离服务之间相互影响</p>\n</li>\n<li><p>服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</p>\n</li>\n</ul>\n</li>\n<li><p>服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</p>\n</li>\n<li><p>服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。</p>\n</li>\n<li><p>服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。</p>\n</li>\n<li><p>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 <strong>调用方法要和本地抽象方法的签名完全一致</strong></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}